{
  "version": 3,
  "sources": ["../../ol/source/Source.js", "../../ol/structs/RBush.js", "../../ol/geom/Circle.js", "../../ol/geom/flat/interpolate.js", "../../ol/geom/flat/length.js", "../../ol/geom/LineString.js", "../../ol/geom/flat/center.js", "../../ol/render/Feature.js", "../../ol/source/VectorEventType.js", "../../ol/loadingstrategy.js", "../../ol/featureloader.js", "../../ol/source/Vector.js", "../../ol/structs/LRUCache.js", "../../ol/layer/BaseImage.js", "../../ol/renderer/Layer.js", "../../ol/render/canvas/ZIndexContext.js", "../../ol/renderer/canvas/Layer.js", "../../ol/renderer/canvas/ImageLayer.js", "../../ol/layer/Image.js", "../../ol/layer/TileProperty.js", "../../ol/layer/BaseTile.js", "../../ol/Tile.js", "../../ol/DataTile.js", "../../ol/ImageTile.js", "../../ol/reproj/common.js", "../../ol/reproj/Triangulation.js", "../../ol/reproj.js", "../../ol/reproj/DataTile.js", "../../ol/reproj/Tile.js", "../../ol/TileRange.js", "../../ol/tilecoord.js", "../../ol/renderer/canvas/TileLayer.js", "../../ol/layer/Tile.js", "../../ol/ImageCanvas.js", "../../ol/resolution.js"],
  "sourcesContent": ["/**\n * @module ol/source/Source\n */\nimport BaseObject from '../Object.js';\nimport {get as getProjection} from '../proj.js';\n\n/**\n * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State\n * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.\n */\n\n/**\n * A function that takes a {@link import(\"../View.js\").ViewStateLayerStateExtent} and returns a string or\n * an array of strings representing source attributions.\n *\n * @typedef {function(import(\"../View.js\").ViewStateLayerStateExtent): (string|Array<string>)} Attribution\n */\n\n/**\n * A type that can be used to provide attribution information for data sources.\n *\n * It represents either\n * * a simple string (e.g. `'© Acme Inc.'`)\n * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)\n * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})\n *\n * @typedef {string|Array<string>|Attribution} AttributionLike\n */\n\n/**\n * @typedef {Object} Options\n * @property {AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {import(\"./Source.js\").State} [state='ready'] State.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for {@link module:ol/layer/Layer~Layer} sources.\n *\n * A generic `change` event is triggered when the state of the source changes.\n * @abstract\n * @api\n */\nclass Source extends BaseObject {\n  /**\n   * @param {Options} options Source options.\n   */\n  constructor(options) {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|null}\n     */\n    this.projection = getProjection(options.projection);\n\n    /**\n     * @private\n     * @type {?Attribution}\n     */\n    this.attributions_ = adaptAttributions(options.attributions);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.attributionsCollapsible_ = options.attributionsCollapsible ?? true;\n\n    /**\n     * This source is currently loading data. Sources that defer loading to the\n     * map's tile queue never set this to `true`.\n     * @type {boolean}\n     */\n    this.loading = false;\n\n    /**\n     * @private\n     * @type {import(\"./Source.js\").State}\n     */\n    this.state_ = options.state !== undefined ? options.state : 'ready';\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.interpolate_ = !!options.interpolate;\n\n    /**\n     * @protected\n     * @type {function(import(\"../View.js\").ViewOptions):void}\n     */\n    this.viewResolver = null;\n\n    /**\n     * @protected\n     * @type {function(Error):void}\n     */\n    this.viewRejector = null;\n\n    const self = this;\n    /**\n     * @private\n     * @type {Promise<import(\"../View.js\").ViewOptions>}\n     */\n    this.viewPromise_ = new Promise(function (resolve, reject) {\n      self.viewResolver = resolve;\n      self.viewRejector = reject;\n    });\n  }\n\n  /**\n   * Get the attribution function for the source.\n   * @return {?Attribution} Attribution function.\n   * @api\n   */\n  getAttributions() {\n    return this.attributions_;\n  }\n\n  /**\n   * @return {boolean} Attributions are collapsible.\n   * @api\n   */\n  getAttributionsCollapsible() {\n    return this.attributionsCollapsible_;\n  }\n\n  /**\n   * Get the projection of the source.\n   * @return {import(\"../proj/Projection.js\").default|null} Projection.\n   * @api\n   */\n  getProjection() {\n    return this.projection;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   */\n  getResolutions(projection) {\n    return null;\n  }\n\n  /**\n   * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n   */\n  getView() {\n    return this.viewPromise_;\n  }\n\n  /**\n   * Get the state of the source, see {@link import(\"./Source.js\").State} for possible states.\n   * @return {import(\"./Source.js\").State} State.\n   * @api\n   */\n  getState() {\n    return this.state_;\n  }\n\n  /**\n   * @return {boolean|undefined} Wrap X.\n   */\n  getWrapX() {\n    return this.wrapX_;\n  }\n\n  /**\n   * @return {boolean} Use linear interpolation when resampling.\n   */\n  getInterpolate() {\n    return this.interpolate_;\n  }\n\n  /**\n   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.\n   * @api\n   */\n  refresh() {\n    this.changed();\n  }\n\n  /**\n   * Set the attributions of the source.\n   * @param {AttributionLike|undefined} attributions Attributions.\n   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},\n   *     or `undefined`.\n   * @api\n   */\n  setAttributions(attributions) {\n    this.attributions_ = adaptAttributions(attributions);\n    this.changed();\n  }\n\n  /**\n   * Set the state of the source.\n   * @param {import(\"./Source.js\").State} state State.\n   */\n  setState(state) {\n    this.state_ = state;\n    this.changed();\n  }\n}\n\n/**\n * Turns the attributions option into an attributions function.\n * @param {AttributionLike|undefined} attributionLike The attribution option.\n * @return {Attribution|null} An attribution function (or null).\n */\nfunction adaptAttributions(attributionLike) {\n  if (!attributionLike) {\n    return null;\n  }\n  if (typeof attributionLike === 'function') {\n    return attributionLike;\n  }\n  if (!Array.isArray(attributionLike)) {\n    attributionLike = [attributionLike];\n  }\n  return (frameState) => attributionLike;\n}\n\nexport default Source;\n", "/**\n * @module ol/structs/RBush\n */\nimport RBush_ from 'rbush';\nimport {createOrUpdate, equals} from '../extent.js';\nimport {getUid} from '../util.js';\nimport {isEmpty} from '../obj.js';\n\n/**\n * @typedef {import(\"rbush\").BBox & {value: T}} Entry\n * @template T\n */\n\n/**\n * @classdesc\n * Wrapper around the RBush by Vladimir Agafonkin.\n * See https://github.com/mourner/rbush.\n *\n * @template {Object} T\n */\nclass RBush {\n  /**\n   * @param {number} [maxEntries] Max entries.\n   */\n  constructor(maxEntries) {\n    /**\n     * @private\n     * @type {RBush_<Entry<T>>}\n     */\n    this.rbush_ = new RBush_(maxEntries);\n\n    /**\n     * A mapping between the objects added to this rbush wrapper\n     * and the objects that are actually added to the internal rbush.\n     * @private\n     * @type {Object<string, Entry<T>>}\n     */\n    this.items_ = {};\n  }\n\n  /**\n   * Insert a value into the RBush.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {T} value Value.\n   */\n  insert(extent, value) {\n    /** @type {Entry<T>} */\n    const item = {\n      minX: extent[0],\n      minY: extent[1],\n      maxX: extent[2],\n      maxY: extent[3],\n      value: value,\n    };\n\n    this.rbush_.insert(item);\n    this.items_[getUid(value)] = item;\n  }\n\n  /**\n   * Bulk-insert values into the RBush.\n   * @param {Array<import(\"../extent.js\").Extent>} extents Extents.\n   * @param {Array<T>} values Values.\n   */\n  load(extents, values) {\n    const items = new Array(values.length);\n    for (let i = 0, l = values.length; i < l; i++) {\n      const extent = extents[i];\n      const value = values[i];\n\n      /** @type {Entry<T>} */\n      const item = {\n        minX: extent[0],\n        minY: extent[1],\n        maxX: extent[2],\n        maxY: extent[3],\n        value: value,\n      };\n      items[i] = item;\n      this.items_[getUid(value)] = item;\n    }\n    this.rbush_.load(items);\n  }\n\n  /**\n   * Remove a value from the RBush.\n   * @param {T} value Value.\n   * @return {boolean} Removed.\n   */\n  remove(value) {\n    const uid = getUid(value);\n\n    // get the object in which the value was wrapped when adding to the\n    // internal rbush. then use that object to do the removal.\n    const item = this.items_[uid];\n    delete this.items_[uid];\n    return this.rbush_.remove(item) !== null;\n  }\n\n  /**\n   * Update the extent of a value in the RBush.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {T} value Value.\n   */\n  update(extent, value) {\n    const item = this.items_[getUid(value)];\n    const bbox = [item.minX, item.minY, item.maxX, item.maxY];\n    if (!equals(bbox, extent)) {\n      this.remove(value);\n      this.insert(extent, value);\n    }\n  }\n\n  /**\n   * Return all values in the RBush.\n   * @return {Array<T>} All.\n   */\n  getAll() {\n    const items = this.rbush_.all();\n    return items.map(function (item) {\n      return item.value;\n    });\n  }\n\n  /**\n   * Return all values in the given extent.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<T>} All in extent.\n   */\n  getInExtent(extent) {\n    /** @type {import(\"rbush\").BBox} */\n    const bbox = {\n      minX: extent[0],\n      minY: extent[1],\n      maxX: extent[2],\n      maxY: extent[3],\n    };\n    const items = this.rbush_.search(bbox);\n    return items.map(function (item) {\n      return item.value;\n    });\n  }\n\n  /**\n   * Calls a callback function with each value in the tree.\n   * If the callback returns a truthy value, this value is returned without\n   * checking the rest of the tree.\n   * @param {function(T): *} callback Callback.\n   * @return {*} Callback return value.\n   */\n  forEach(callback) {\n    return this.forEach_(this.getAll(), callback);\n  }\n\n  /**\n   * Calls a callback function with each value in the provided extent.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {function(T): *} callback Callback.\n   * @return {*} Callback return value.\n   */\n  forEachInExtent(extent, callback) {\n    return this.forEach_(this.getInExtent(extent), callback);\n  }\n\n  /**\n   * @param {Array<T>} values Values.\n   * @param {function(T): *} callback Callback.\n   * @private\n   * @return {*} Callback return value.\n   */\n  forEach_(values, callback) {\n    let result;\n    for (let i = 0, l = values.length; i < l; i++) {\n      result = callback(values[i]);\n      if (result) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return isEmpty(this.items_);\n  }\n\n  /**\n   * Remove all values from the RBush.\n   */\n  clear() {\n    this.rbush_.clear();\n    this.items_ = {};\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} [extent] Extent.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   */\n  getExtent(extent) {\n    const data = this.rbush_.toJSON();\n    return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, extent);\n  }\n\n  /**\n   * @param {RBush<T>} rbush R-Tree.\n   */\n  concat(rbush) {\n    this.rbush_.load(rbush.rbush_.all());\n    for (const i in rbush.items_) {\n      this.items_[i] = rbush.items_[i];\n    }\n  }\n}\n\nexport default RBush;\n", "/**\n * @module ol/geom/Circle\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {createOrUpdate, forEachCorner, intersects} from '../extent.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {rotate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nclass Circle extends SimpleGeometry {\n  /**\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   *     For internal use, flat coordinates in combination with `layout` and no\n   *     `radius` are also accepted.\n   * @param {number} [radius] Radius in units of the projection.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(center, radius, layout) {\n    super();\n    if (layout !== undefined && radius === undefined) {\n      this.setFlatCoordinates(layout, center);\n    } else {\n      radius = radius ? radius : 0;\n      this.setCenterAndRadius(center, radius, layout);\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const circle = new Circle(\n      this.flatCoordinates.slice(),\n      undefined,\n      this.layout,\n    );\n    circle.applyProperties(this);\n    return circle;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    const squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (let i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        const delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (let i = 2; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   * @override\n   */\n  containsXY(x, y) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  }\n\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */\n  getCenter() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @override\n   */\n  computeExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(\n      flatCoordinates[0] - radius,\n      flatCoordinates[1] - radius,\n      flatCoordinates[0] + radius,\n      flatCoordinates[1] + radius,\n      extent,\n    );\n  }\n\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return Math.sqrt(this.getRadiusSquared_());\n  }\n\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  getRadiusSquared_() {\n    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'Circle';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    const circleExtent = this.getExtent();\n    if (intersects(extent, circleExtent)) {\n      const center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n    }\n    return false;\n  }\n\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */\n  setCenter(center) {\n    const stride = this.stride;\n    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    const flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (let i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  }\n\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCenterAndRadius(center, radius, layout) {\n    this.setLayout(layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array<number>} */\n    const flatCoordinates = this.flatCoordinates;\n    let offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    for (let i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  }\n\n  /**\n   * @override\n   */\n  getCoordinates() {\n    return null;\n  }\n\n  /**\n   * @override\n   */\n  setCoordinates(coordinates, layout) {}\n\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  setRadius(radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   * @override\n   */\n  rotate(angle, anchor) {\n    const center = this.getCenter();\n    const stride = this.getStride();\n    this.setCenter(\n      rotate(center, 0, center.length, stride, angle, anchor, center),\n    );\n    this.changed();\n  }\n}\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n", "/**\n * @module ol/geom/flat/interpolate\n */\nimport {binarySearch} from '../../array.js';\nimport {lerp} from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>} [dest] Destination.\n * @param {number} [dimension] Destination dimension (default is `2`)\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  fraction,\n  dest,\n  dimension,\n) {\n  let o, t;\n  const n = (end - offset) / stride;\n  if (n === 1) {\n    o = offset;\n  } else if (n === 2) {\n    o = offset;\n    t = fraction;\n  } else if (n !== 0) {\n    let x1 = flatCoordinates[offset];\n    let y1 = flatCoordinates[offset + 1];\n    let length = 0;\n    const cumulativeLengths = [0];\n    for (let i = offset + stride; i < end; i += stride) {\n      const x2 = flatCoordinates[i];\n      const y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    const target = fraction * length;\n    const index = binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      t =\n        (target - cumulativeLengths[-index - 2]) /\n        (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      o = offset + (-index - 2) * stride;\n    } else {\n      o = offset + index * stride;\n    }\n  }\n  dimension = dimension > 1 ? dimension : 2;\n  dest = dest ? dest : new Array(dimension);\n  for (let i = 0; i < dimension; ++i) {\n    dest[i] =\n      o === undefined\n        ? NaN\n        : t === undefined\n          ? flatCoordinates[o + i]\n          : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n  }\n  return dest;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringCoordinateAtM(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  m,\n  extrapolate,\n) {\n  if (end == offset) {\n    return null;\n  }\n  let coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  let lo = offset / stride;\n  let hi = end / stride;\n  while (lo < hi) {\n    const mid = (lo + hi) >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  const m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  const m1 = flatCoordinates[(lo + 1) * stride - 1];\n  const t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  for (let i = 0; i < stride - 1; ++i) {\n    coordinate.push(\n      lerp(\n        flatCoordinates[(lo - 1) * stride + i],\n        flatCoordinates[lo * stride + i],\n        t,\n      ),\n    );\n  }\n  coordinate.push(m);\n  return coordinate;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringsCoordinateAtM(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  m,\n  extrapolate,\n  interpolate,\n) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(\n      flatCoordinates,\n      offset,\n      ends[ends.length - 1],\n      stride,\n      m,\n      extrapolate,\n    );\n  }\n  let coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    }\n    if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        m,\n        false,\n      );\n    }\n    offset = end;\n  }\n  return null;\n}\n", "/**\n * @module ol/geom/flat/length\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Length.\n */\nexport function lineStringLength(flatCoordinates, offset, end, stride) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  let length = 0;\n  for (let i = offset + stride; i < end; i += stride) {\n    const x2 = flatCoordinates[i];\n    const y2 = flatCoordinates[i + 1];\n    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    x1 = x2;\n    y1 = y2;\n  }\n  return length;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Perimeter.\n */\nexport function linearRingLength(flatCoordinates, offset, end, stride) {\n  let perimeter = lineStringLength(flatCoordinates, offset, end, stride);\n  const dx = flatCoordinates[end - stride] - flatCoordinates[offset];\n  const dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];\n  perimeter += Math.sqrt(dx * dx + dy * dy);\n  return perimeter;\n}\n", "/**\n * @module ol/geom/LineString\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {douglasPeucker} from './flat/simplify.js';\nimport {extend} from '../array.js';\nimport {forEach as forEachSegment} from './flat/segments.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {interpolatePoint, lineStringCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineString} from './flat/intersectsextent.js';\nimport {lineStringLength} from './flat/length.js';\n\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nclass LineString extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate|null}\n     */\n    this.flatMidpoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatMidpointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n    } else {\n      this.setCoordinates(\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    }\n  }\n\n  /**\n   * Append the passed coordinate to the coordinates of the linestring.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @api\n   */\n  appendCoordinate(coordinate) {\n    extend(this.flatCoordinates, coordinate);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LineString} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const lineString = new LineString(\n      this.flatCoordinates.slice(),\n      this.layout,\n    );\n    lineString.applyProperties(this);\n    return lineString;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        maxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.flatCoordinates.length,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      this.maxDelta_,\n      false,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * Iterate over each segment, calling the provided callback.\n   * If the callback returns a truthy value the function returns that\n   * value immediately. Otherwise the function returns `false`.\n   *\n   * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.\n   * @return {T|boolean} Value.\n   * @template T,S\n   * @api\n   */\n  forEachSegment(callback) {\n    return forEachSegment(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      callback,\n    );\n  }\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * @param {number} m M.\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n   * @api\n   */\n  getCoordinateAtM(m, extrapolate) {\n    if (this.layout != 'XYM' && this.layout != 'XYZM') {\n      return null;\n    }\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\n    return lineStringCoordinateAtM(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      m,\n      extrapolate,\n    );\n  }\n\n  /**\n   * Return the coordinates of the linestring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   * @override\n   */\n  getCoordinates() {\n    return inflateCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * Return the coordinate at the provided fraction along the linestring.\n   * The `fraction` is a number between 0 and 1, where 0 is the start of the\n   * linestring and 1 is the end.\n   * @param {number} fraction Fraction.\n   * @param {import(\"../coordinate.js\").Coordinate} [dest] Optional coordinate whose values will\n   *     be modified. If not provided, a new coordinate will be returned.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n   * @api\n   */\n  getCoordinateAt(fraction, dest) {\n    return interpolatePoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      fraction,\n      dest,\n      this.stride,\n    );\n  }\n\n  /**\n   * Return the length of the linestring on projected plane.\n   * @return {number} Length (on projected plane).\n   * @api\n   */\n  getLength() {\n    return lineStringLength(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  getFlatMidpoint() {\n    if (this.flatMidpointRevision_ != this.getRevision()) {\n      this.flatMidpoint_ = this.getCoordinateAt(\n        0.5,\n        this.flatMidpoint_ ?? undefined,\n      );\n      this.flatMidpointRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.flatMidpoint_);\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} Simplified LineString.\n   * @protected\n   * @override\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n    );\n    return new LineString(simplifiedFlatCoordinates, 'XY');\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'LineString';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    return intersectsLineString(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      extent,\n    );\n  }\n\n  /**\n   * Set the coordinates of the linestring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   * @override\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n    );\n    this.changed();\n  }\n}\n\nexport default LineString;\n", "/**\n * @module ol/geom/flat/center\n */\nimport {createEmpty, createOrUpdateFromFlatCoordinates} from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {Array<number>} Flat centers.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n  const flatCenters = [];\n  let extent = createEmpty();\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    extent = createOrUpdateFromFlatCoordinates(\n      flatCoordinates,\n      offset,\n      ends[0],\n      stride,\n    );\n    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n    offset = ends[ends.length - 1];\n  }\n  return flatCenters;\n}\n", "/**\n * @module ol/render/Feature\n */\nimport Feature from '../Feature.js';\nimport {\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from '../geom.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../transform.js';\nimport {\n  createOrUpdateFromCoordinate,\n  createOrUpdateFromFlatCoordinates,\n  getCenter,\n  getHeight,\n} from '../extent.js';\nimport {\n  douglasPeucker,\n  douglasPeuckerArray,\n  quantizeArray,\n} from '../geom/flat/simplify.js';\nimport {extend} from '../array.js';\nimport {\n  getInteriorPointOfArray,\n  getInteriorPointsOfMultiArray,\n} from '../geom/flat/interiorpoint.js';\nimport {get as getProjection} from '../proj.js';\nimport {inflateEnds} from '../geom/flat/orient.js';\nimport {interpolatePoint} from '../geom/flat/interpolate.js';\nimport {linearRingss as linearRingssCenter} from '../geom/flat/center.js';\nimport {memoizeOne} from '../functions.js';\nimport {transform2D} from '../geom/flat/transform.js';\n\n/**\n * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString'} Type\n * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'` or 'MultiLineString'`.\n */\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nconst tmpTransform = createTransform();\n\n/**\n * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like\n * structure, optimized for vector tile rendering and styling. Geometry access\n * through the API is limited to getting the type and extent of the geometry.\n */\nclass RenderFeature {\n  /**\n   * @param {Type} type Geometry type.\n   * @param {Array<number>} flatCoordinates Flat coordinates. These always need\n   *     to be right-handed for polygons.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Object<string, *>} properties Properties.\n   * @param {number|string|undefined} id Feature id.\n   */\n  constructor(type, flatCoordinates, ends, stride, properties, id) {\n    /**\n     * @type {import(\"../style/Style.js\").StyleFunction|undefined}\n     */\n    this.styleFunction;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent|undefined}\n     */\n    this.extent_;\n\n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n    this.id_ = id;\n\n    /**\n     * @private\n     * @type {Type}\n     */\n    this.type_ = type;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatCoordinates_ = flatCoordinates;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatMidpoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.ends_ = ends || null;\n\n    /**\n     * @private\n     * @type {Object<string, *>}\n     */\n    this.properties_ = properties;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.squaredTolerance_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.stride_ = stride;\n\n    /**\n     * @private\n     * @type {RenderFeature}\n     */\n    this.simplifiedGeometry_;\n  }\n\n  /**\n   * Get a feature property by its key.\n   * @param {string} key Key\n   * @return {*} Value for the requested key.\n   * @api\n   */\n  get(key) {\n    return this.properties_[key];\n  }\n\n  /**\n   * Get the extent of this feature's geometry.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    if (!this.extent_) {\n      this.extent_ =\n        this.type_ === 'Point'\n          ? createOrUpdateFromCoordinate(this.flatCoordinates_)\n          : createOrUpdateFromFlatCoordinates(\n              this.flatCoordinates_,\n              0,\n              this.flatCoordinates_.length,\n              2,\n            );\n    }\n    return this.extent_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoint() {\n    if (!this.flatInteriorPoints_) {\n      const flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoints_ = getInteriorPointOfArray(\n        this.flatCoordinates_,\n        0,\n        this.ends_,\n        2,\n        flatCenter,\n        0,\n      );\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (!this.flatInteriorPoints_) {\n      const ends = inflateEnds(this.flatCoordinates_, this.ends_);\n      const flatCenters = linearRingssCenter(this.flatCoordinates_, 0, ends, 2);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.flatCoordinates_,\n        0,\n        ends,\n        2,\n        flatCenters,\n      );\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  getFlatMidpoint() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = interpolatePoint(\n        this.flatCoordinates_,\n        0,\n        this.flatCoordinates_.length,\n        2,\n        0.5,\n      );\n    }\n    return this.flatMidpoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  getFlatMidpoints() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = [];\n      const flatCoordinates = this.flatCoordinates_;\n      let offset = 0;\n      const ends = /** @type {Array<number>} */ (this.ends_);\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        const end = ends[i];\n        const midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);\n        extend(this.flatMidpoints_, midpoint);\n        offset = end;\n      }\n    }\n    return this.flatMidpoints_;\n  }\n\n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is set when reading data from a remote source.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  getId() {\n    return this.id_;\n  }\n\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    return this.flatCoordinates_;\n  }\n\n  /**\n   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when\n   * determining the geometry type in style function (see {@link #getType}).\n   * @return {RenderFeature} Feature.\n   * @api\n   */\n  getGeometry() {\n    return this;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    return this;\n  }\n\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  simplifyTransformed(squaredTolerance, transform) {\n    return this;\n  }\n\n  /**\n   * Get the feature properties.\n   * @return {Object<string, *>} Feature properties.\n   * @api\n   */\n  getProperties() {\n    return this.properties_;\n  }\n\n  /**\n   * Get an object of all property names and values.  This has the same behavior as getProperties,\n   * but is here to conform with the {@link module:ol/Feature~Feature} interface.\n   * @return {Object<string, *>?} Object.\n   */\n  getPropertiesInternal() {\n    return this.properties_;\n  }\n\n  /**\n   * @return {number} Stride.\n   */\n  getStride() {\n    return this.stride_;\n  }\n\n  /**\n   * @return {import('../style/Style.js').StyleFunction|undefined} Style\n   */\n  getStyleFunction() {\n    return this.styleFunction;\n  }\n\n  /**\n   * Get the type of this feature's geometry.\n   * @return {Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return this.type_;\n  }\n\n  /**\n   * Transform geometry coordinates from tile pixel space to projected.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection The data projection\n   */\n  transform(projection) {\n    projection = getProjection(projection);\n    const pixelExtent = projection.getExtent();\n    const projectedExtent = projection.getWorldExtent();\n    if (pixelExtent && projectedExtent) {\n      const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n      composeTransform(\n        tmpTransform,\n        projectedExtent[0],\n        projectedExtent[3],\n        scale,\n        -scale,\n        0,\n        0,\n        0,\n      );\n      transform2D(\n        this.flatCoordinates_,\n        0,\n        this.flatCoordinates_.length,\n        2,\n        tmpTransform,\n        this.flatCoordinates_,\n      );\n    }\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   */\n  applyTransform(transformFn) {\n    transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);\n  }\n\n  /**\n   * @return {RenderFeature} A cloned render feature.\n   */\n  clone() {\n    return new RenderFeature(\n      this.type_,\n      this.flatCoordinates_.slice(),\n      this.ends_?.slice(),\n      this.stride_,\n      Object.assign({}, this.properties_),\n      this.id_,\n    );\n  }\n\n  /**\n   * @return {Array<number>|null} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * Add transform and resolution based geometry simplification to this instance.\n   * @return {RenderFeature} This render feature.\n   */\n  enableSimplifyTransformed() {\n    this.simplifyTransformed = memoizeOne((squaredTolerance, transform) => {\n      if (squaredTolerance === this.squaredTolerance_) {\n        return this.simplifiedGeometry_;\n      }\n      this.simplifiedGeometry_ = this.clone();\n      if (transform) {\n        this.simplifiedGeometry_.applyTransform(transform);\n      }\n      const simplifiedFlatCoordinates =\n        this.simplifiedGeometry_.getFlatCoordinates();\n      let simplifiedEnds;\n      switch (this.type_) {\n        case 'LineString':\n          simplifiedFlatCoordinates.length = douglasPeucker(\n            simplifiedFlatCoordinates,\n            0,\n            this.simplifiedGeometry_.flatCoordinates_.length,\n            this.simplifiedGeometry_.stride_,\n            squaredTolerance,\n            simplifiedFlatCoordinates,\n            0,\n          );\n          simplifiedEnds = [simplifiedFlatCoordinates.length];\n          break;\n        case 'MultiLineString':\n          simplifiedEnds = [];\n          simplifiedFlatCoordinates.length = douglasPeuckerArray(\n            simplifiedFlatCoordinates,\n            0,\n            this.simplifiedGeometry_.ends_,\n            this.simplifiedGeometry_.stride_,\n            squaredTolerance,\n            simplifiedFlatCoordinates,\n            0,\n            simplifiedEnds,\n          );\n          break;\n        case 'Polygon':\n          simplifiedEnds = [];\n          simplifiedFlatCoordinates.length = quantizeArray(\n            simplifiedFlatCoordinates,\n            0,\n            this.simplifiedGeometry_.ends_,\n            this.simplifiedGeometry_.stride_,\n            Math.sqrt(squaredTolerance),\n            simplifiedFlatCoordinates,\n            0,\n            simplifiedEnds,\n          );\n          break;\n        default:\n      }\n      if (simplifiedEnds) {\n        this.simplifiedGeometry_ = new RenderFeature(\n          this.type_,\n          simplifiedFlatCoordinates,\n          simplifiedEnds,\n          2,\n          this.properties_,\n          this.id_,\n        );\n      }\n      this.squaredTolerance_ = squaredTolerance;\n      return this.simplifiedGeometry_;\n    });\n    return this;\n  }\n}\n\n/**\n * @return {Array<number>} Flat coordinates.\n */\nRenderFeature.prototype.getFlatCoordinates =\n  RenderFeature.prototype.getOrientedFlatCoordinates;\n\n/**\n * Create a geometry from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature\n * Render Feature\n * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}\n * New geometry instance.\n * @api\n */\nexport function toGeometry(renderFeature) {\n  const geometryType = renderFeature.getType();\n  switch (geometryType) {\n    case 'Point':\n      return new Point(renderFeature.getFlatCoordinates());\n    case 'MultiPoint':\n      return new MultiPoint(renderFeature.getFlatCoordinates(), 'XY');\n    case 'LineString':\n      return new LineString(renderFeature.getFlatCoordinates(), 'XY');\n    case 'MultiLineString':\n      return new MultiLineString(\n        renderFeature.getFlatCoordinates(),\n        'XY',\n        /** @type {Array<number>} */ (renderFeature.getEnds()),\n      );\n    case 'Polygon':\n      const flatCoordinates = renderFeature.getFlatCoordinates();\n      const ends = renderFeature.getEnds();\n      const endss = inflateEnds(flatCoordinates, ends);\n      return endss.length > 1\n        ? new MultiPolygon(flatCoordinates, 'XY', endss)\n        : new Polygon(flatCoordinates, 'XY', ends);\n    default:\n      throw new Error('Invalid geometry type:' + geometryType);\n  }\n}\n\n/**\n * Create an `ol/Feature` from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature RenderFeature\n * @param {string} [geometryName='geometry'] Geometry name to use\n * when creating the Feature.\n * @return {Feature} Newly constructed `ol/Feature` with properties,\n * geometry, and id copied over.\n * @api\n */\nexport function toFeature(renderFeature, geometryName) {\n  const id = renderFeature.getId();\n  const geometry = toGeometry(renderFeature);\n  const properties = renderFeature.getProperties();\n  const feature = new Feature();\n  if (geometryName !== undefined) {\n    feature.setGeometryName(geometryName);\n  }\n  feature.setGeometry(geometry);\n  if (id !== undefined) {\n    feature.setId(id);\n  }\n  feature.setProperties(properties, true);\n  return feature;\n}\n\nexport default RenderFeature;\n", "/**\n * @module ol/source/VectorEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a feature is added to the source.\n   * @event module:ol/source/Vector.VectorSourceEvent#addfeature\n   * @api\n   */\n  ADDFEATURE: 'addfeature',\n\n  /**\n   * Triggered when a feature is updated.\n   * @event module:ol/source/Vector.VectorSourceEvent#changefeature\n   * @api\n   */\n  CHANGEFEATURE: 'changefeature',\n\n  /**\n   * Triggered when the clear method is called on the source.\n   * @event module:ol/source/Vector.VectorSourceEvent#clear\n   * @api\n   */\n  CLEAR: 'clear',\n\n  /**\n   * Triggered when a feature is removed from the source.\n   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.\n   * @event module:ol/source/Vector.VectorSourceEvent#removefeature\n   * @api\n   */\n  REMOVEFEATURE: 'removefeature',\n\n  /**\n   * Triggered when features starts loading.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart\n   * @api\n   */\n  FEATURESLOADSTART: 'featuresloadstart',\n\n  /**\n   * Triggered when features finishes loading.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend\n   * @api\n   */\n  FEATURESLOADEND: 'featuresloadend',\n\n  /**\n   * Triggered if feature loading results in an error.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror\n   * @api\n   */\n  FEATURESLOADERROR: 'featuresloaderror',\n};\n\n/**\n * @typedef {'addfeature'|'changefeature'|'clear'|'removefeature'|'featuresloadstart'|'featuresloadend'|'featuresloaderror'} VectorSourceEventTypes\n */\n", "/**\n * @module ol/loadingstrategy\n */\n\nimport {fromUserExtent, fromUserResolution, toUserExtent} from './proj.js';\n\n/**\n * Strategy function for loading all features with a single request.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array<import(\"./extent.js\").Extent>} Extents.\n * @api\n */\nexport function all(extent, resolution) {\n  return [[-Infinity, -Infinity, Infinity, Infinity]];\n}\n\n/**\n * Strategy function for loading features based on the view's extent and\n * resolution.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array<import(\"./extent.js\").Extent>} Extents.\n * @api\n */\nexport function bbox(extent, resolution) {\n  return [extent];\n}\n\n/**\n * Creates a strategy function for loading features based on a tile grid.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {function(import(\"./extent.js\").Extent, number, import(\"./proj.js\").Projection): Array<import(\"./extent.js\").Extent>} Loading strategy.\n * @api\n */\nexport function tile(tileGrid) {\n  return (\n    /**\n     * @param {import(\"./extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"./proj.js\").Projection} projection Projection.\n     * @return {Array<import(\"./extent.js\").Extent>} Extents.\n     */\n    function (extent, resolution, projection) {\n      const z = tileGrid.getZForResolution(\n        fromUserResolution(resolution, projection),\n      );\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        fromUserExtent(extent, projection),\n        z,\n      );\n      /** @type {Array<import(\"./extent.js\").Extent>} */\n      const extents = [];\n      /** @type {import(\"./tilecoord.js\").TileCoord} */\n      const tileCoord = [z, 0, 0];\n      for (\n        tileCoord[1] = tileRange.minX;\n        tileCoord[1] <= tileRange.maxX;\n        ++tileCoord[1]\n      ) {\n        for (\n          tileCoord[2] = tileRange.minY;\n          tileCoord[2] <= tileRange.maxY;\n          ++tileCoord[2]\n        ) {\n          extents.push(\n            toUserExtent(tileGrid.getTileCoordExtent(tileCoord), projection),\n          );\n        }\n      }\n      return extents;\n    }\n  );\n}\n", "/**\n * @module ol/featureloader\n */\nimport {VOID} from './functions.js';\n\n/**\n *\n * @type {boolean}\n * @private\n */\nlet withCredentials = false;\n\n/**\n * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to\n * load features.\n *\n * This function takes up to 5 arguments. These are an {@link module:ol/extent~Extent} representing\n * the area to be loaded, a `{number}` representing the resolution (map units per pixel), a\n * {@link module:ol/proj/Projection~Projection} for the projection, an optional success callback that should get\n * the loaded features passed as an argument and an optional failure callback with no arguments. If\n * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and\n * `'featuresloaderror'` events. `this` within the function is bound to the\n * {@link module:ol/source/Vector~VectorSource} it's called from.\n *\n * The function is responsible for loading the features and adding them to the\n * source.\n *\n * @template {import(\"./Feature.js\").FeatureLike} [FeatureType=import(\"./Feature.js\").default]\n * @typedef {function(this:(import(\"./source/Vector\").default<FeatureType>|import(\"./VectorTile.js\").default),\n *           import(\"./extent.js\").Extent,\n *           number,\n *           import(\"./proj/Projection.js\").default,\n *           function(Array<FeatureType>): void=,\n *           function(): void=): void} FeatureLoader\n * @api\n */\n\n/**\n * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to\n * get the url to load features from.\n *\n * This function takes an {@link module:ol/extent~Extent} representing the area\n * to be loaded, a `{number}` representing the resolution (map units per pixel)\n * and an {@link module:ol/proj/Projection~Projection} for the projection  as\n * arguments and returns a `{string}` representing the URL.\n * @typedef {function(import(\"./extent.js\").Extent, number, import(\"./proj/Projection.js\").default): string} FeatureUrlFunction\n * @api\n */\n\n/**\n * @template {import(\"./Feature.js\").FeatureLike} [FeatureType=import(\"./Feature.js\").default]\n * @param {string|FeatureUrlFunction} url Feature URL service.\n * @param {import(\"./format/Feature.js\").default<FeatureType>} format Feature format.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @param {function(Array<FeatureType>, import(\"./proj/Projection.js\").default): void} success Success\n *      Function called with the loaded features and optionally with the data projection.\n * @param {function(): void} failure Failure\n *      Function called when loading failed.\n */\nexport function loadFeaturesXhr(\n  url,\n  format,\n  extent,\n  resolution,\n  projection,\n  success,\n  failure,\n) {\n  const xhr = new XMLHttpRequest();\n  xhr.open(\n    'GET',\n    typeof url === 'function' ? url(extent, resolution, projection) : url,\n    true,\n  );\n  if (format.getType() == 'arraybuffer') {\n    xhr.responseType = 'arraybuffer';\n  }\n  xhr.withCredentials = withCredentials;\n  /**\n   * @param {Event} event Event.\n   * @private\n   */\n  xhr.onload = function (event) {\n    // status will be 0 for file:// urls\n    if (!xhr.status || (xhr.status >= 200 && xhr.status < 300)) {\n      const type = format.getType();\n      try {\n        /** @type {Document|Node|Object|string|undefined} */\n        let source;\n        if (type == 'text' || type == 'json') {\n          source = xhr.responseText;\n        } else if (type == 'xml') {\n          source = xhr.responseXML || xhr.responseText;\n        } else if (type == 'arraybuffer') {\n          source = /** @type {ArrayBuffer} */ (xhr.response);\n        }\n        if (source) {\n          success(\n            /** @type {Array<FeatureType>} */\n            (\n              format.readFeatures(source, {\n                extent: extent,\n                featureProjection: projection,\n              })\n            ),\n            format.readProjection(source),\n          );\n        } else {\n          failure();\n        }\n      } catch {\n        failure();\n      }\n    } else {\n      failure();\n    }\n  };\n  /**\n   * @private\n   */\n  xhr.onerror = failure;\n  xhr.send();\n}\n\n/**\n * Create an XHR feature loader for a `url` and `format`. The feature loader\n * loads features (with XHR), parses the features, and adds them to the\n * vector source.\n * @template {import(\"./Feature.js\").FeatureLike} FeatureType\n * @param {string|FeatureUrlFunction} url Feature URL service.\n * @param {import(\"./format/Feature.js\").default<FeatureType>} format Feature format.\n * @return {FeatureLoader<FeatureType>} The feature loader.\n * @api\n */\nexport function xhr(url, format) {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"./proj/Projection.js\").default} projection Projection.\n   * @param {function(Array<FeatureType>): void} [success] Success\n   *      Function called when loading succeeded.\n   * @param {function(): void} [failure] Failure\n   *      Function called when loading failed.\n   */\n  return function (extent, resolution, projection, success, failure) {\n    const source =\n      /** @type {import(\"./source/Vector\").default<FeatureType>} */ (this);\n    loadFeaturesXhr(\n      url,\n      format,\n      extent,\n      resolution,\n      projection,\n      /**\n       * @param {Array<FeatureType>} features The loaded features.\n       * @param {import(\"./proj/Projection.js\").default} dataProjection Data\n       * projection.\n       */\n      function (features, dataProjection) {\n        source.addFeatures(features);\n        if (success !== undefined) {\n          success(features);\n        }\n      },\n      /* FIXME handle error */ failure ? failure : VOID,\n    );\n  };\n}\n\n/**\n * Setter for the withCredentials configuration for the XHR.\n *\n * @param {boolean} xhrWithCredentials The value of withCredentials to set.\n * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/\n * @api\n */\nexport function setWithCredentials(xhrWithCredentials) {\n  withCredentials = xhrWithCredentials;\n}\n", "/**\n * @module ol/source/Vector\n */\n\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport ObjectEventType from '../ObjectEventType.js';\nimport RBush from '../structs/RBush.js';\nimport RenderFeature from '../render/Feature.js';\nimport Source from './Source.js';\nimport VectorEventType from './VectorEventType.js';\nimport {TRUE, VOID} from '../functions.js';\nimport {all as allStrategy} from '../loadingstrategy.js';\nimport {assert} from '../asserts.js';\nimport {containsExtent, equals, wrapAndSliceX} from '../extent.js';\nimport {extend} from '../array.js';\nimport {getUid} from '../util.js';\nimport {isEmpty} from '../obj.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {xhr} from '../featureloader.js';\n\n/**\n * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and\n * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this\n * is one of the standard {@link module:ol/loadingstrategy} strategies.\n *\n * @typedef {function(import(\"../extent.js\").Extent, number, import(\"../proj/Projection.js\").default): Array<import(\"../extent.js\").Extent>} LoadingStrategy\n * @api\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Vector~VectorSource} instances are instances of this\n * type.\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n */\nexport class VectorSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {FeatureType} [feature] Feature.\n   * @param {Array<FeatureType>} [features] Features.\n   */\n  constructor(type, feature, features) {\n    super(type);\n\n    /**\n     * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.\n     * @type {FeatureType|undefined}\n     * @api\n     */\n    this.feature = feature;\n\n    /**\n     * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.\n     * @type {Array<FeatureType>|undefined}\n     * @api\n     */\n    this.features = features;\n  }\n}\n\n/***\n * @template {import(\"../Feature.js\").FeatureLike} [T=import(\"../Feature.js\").default]\n * @typedef {T extends RenderFeature ? T|Array<T> : T} FeatureClassOrArrayOfRenderFeatures\n */\n\n/***\n * @template Return\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./VectorEventType\").VectorSourceEventTypes, VectorSourceEvent<FeatureType>, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     import(\"./VectorEventType\").VectorSourceEventTypes, Return>} VectorSourceOnSignature\n */\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {Array<FeatureType>|Collection<FeatureType>} [features]\n * Features. If provided as {@link module:ol/Collection~Collection}, the features in the source\n * and the collection will stay in sync.\n * @property {import(\"../format/Feature.js\").default<FeatureType>} [format] The feature format used by the XHR\n * feature loader when `url` is set. Required if `url` is set, otherwise ignored.\n * @property {import(\"../featureloader.js\").FeatureLoader<FeatureType>} [loader]\n * The loader function used to load features, from a remote source for example.\n * If this is not set and `url` is set, the source will create and use an XHR\n * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events\n * will only fire if the `success` and `failure` callbacks are used.\n *\n * Example:\n *\n * ```js\n * import Vector from 'ol/source/Vector.js';\n * import GeoJSON from 'ol/format/GeoJSON.js';\n * import {bbox} from 'ol/loadingstrategy.js';\n *\n * const vectorSource = new Vector({\n *   format: new GeoJSON(),\n *   loader: function(extent, resolution, projection, success, failure) {\n *      const proj = projection.getCode();\n *      const url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +\n *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +\n *          'outputFormat=application/json&srsname=' + proj + '&' +\n *          'bbox=' + extent.join(',') + ',' + proj;\n *      const xhr = new XMLHttpRequest();\n *      xhr.open('GET', url);\n *      const onError = function() {\n *        vectorSource.removeLoadedExtent(extent);\n *        failure();\n *      }\n *      xhr.onerror = onError;\n *      xhr.onload = function() {\n *        if (xhr.status == 200) {\n *          const features = vectorSource.getFormat().readFeatures(xhr.responseText);\n *          vectorSource.addFeatures(features);\n *          success(features);\n *        } else {\n *          onError();\n *        }\n *      }\n *      xhr.send();\n *    },\n *    strategy: bbox,\n *  });\n * ```\n * @property {boolean} [overlaps=true] This source may have overlapping geometries.\n * Setting this to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {LoadingStrategy} [strategy] The loading strategy to use.\n * By default an {@link module:ol/loadingstrategy.all}\n * strategy is used, a one-off strategy which loads all features at once.\n * @property {string|import(\"../featureloader.js\").FeatureUrlFunction} [url]\n * Setting this option instructs the source to load features using an XHR loader\n * (see {@link module:ol/featureloader.xhr}). Use a `string` and an\n * {@link module:ol/loadingstrategy.all} for a one-off download of all features from\n * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with\n * other loading strategies.\n * Requires `format` to be set as well.\n * When default XHR feature loader is provided, the features will\n * be transformed from the data projection to the view projection\n * during parsing. If your remote data source does not advertise its projection\n * properly, this transformation will be incorrect. For some formats, the\n * default projection (usually EPSG:4326) can be overridden by setting the\n * dataProjection constructor option on the format.\n * Note that if a source contains non-feature data, such as a GeoJSON geometry\n * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.\n * @property {boolean} [useSpatialIndex=true]\n * By default, an RTree is used as spatial index. When features are removed and\n * added frequently, and the total number of features is low, setting this to\n * `false` may improve performance.\n *\n * Note that\n * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},\n * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and\n * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is\n * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop\n * through all features.\n *\n * When set to `false`, the features will be maintained in an\n * {@link module:ol/Collection~Collection}, which can be retrieved through\n * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.\n * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the\n * -180° and 180° meridians to work properly, this should be set to `false`. The\n * resulting geometry coordinates will then exceed the world bounds.\n */\n\n/**\n * @classdesc\n * Provides a source of features for vector layers. Vector features provided\n * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for\n * vector data that is optimized for rendering.\n *\n * @fires VectorSourceEvent\n * @api\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n */\nclass VectorSource extends Source {\n  /**\n   * @param {Options<FeatureType>} [options] Vector source options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    super({\n      attributions: options.attributions,\n      interpolate: true,\n      projection: undefined,\n      state: 'ready',\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n    });\n\n    /***\n     * @type {VectorSourceOnSignature<import(\"../events\").EventsKey, FeatureType>}\n     */\n    this.on;\n\n    /***\n     * @type {VectorSourceOnSignature<import(\"../events\").EventsKey, FeatureType>}\n     */\n    this.once;\n\n    /***\n     * @type {VectorSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {import(\"../featureloader.js\").FeatureLoader<FeatureType>}\n     */\n    this.loader_ = VOID;\n\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default<FeatureType>|null}\n     */\n    this.format_ = options.format || null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;\n\n    /**\n     * @private\n     * @type {string|import(\"../featureloader.js\").FeatureUrlFunction|undefined}\n     */\n    this.url_ = options.url;\n\n    if (options.loader !== undefined) {\n      this.loader_ = options.loader;\n    } else if (this.url_ !== undefined) {\n      assert(this.format_, '`format` must be set when `url` is set');\n      // create a XHR feature loader for \"url\" and \"format\"\n      this.loader_ = xhr(this.url_, this.format_);\n    }\n\n    /**\n     * @private\n     * @type {LoadingStrategy}\n     */\n    this.strategy_ =\n      options.strategy !== undefined ? options.strategy : allStrategy;\n\n    const useSpatialIndex =\n      options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;\n\n    /**\n     * @private\n     * @type {RBush<FeatureType>}\n     */\n    this.featuresRtree_ = useSpatialIndex ? new RBush() : null;\n\n    /**\n     * @private\n     * @type {RBush<{extent: import(\"../extent.js\").Extent}>}\n     */\n    this.loadedExtentsRtree_ = new RBush();\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.loadingExtentsCount_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, FeatureType>}\n     */\n    this.nullGeometryFeatures_ = {};\n\n    /**\n     * A lookup of features by id (the return from feature.getId()).\n     * @private\n     * @type {!Object<string, import('../Feature.js').FeatureLike|Array<import('../Feature.js').FeatureLike>>}\n     */\n    this.idIndex_ = {};\n\n    /**\n     * A lookup of features by uid (using getUid(feature)).\n     * @private\n     * @type {!Object<string, FeatureType>}\n     */\n    this.uidIndex_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../events.js\").EventsKey>>}\n     */\n    this.featureChangeKeys_ = {};\n\n    /**\n     * @private\n     * @type {Collection<FeatureType>|null}\n     */\n    this.featuresCollection_ = null;\n\n    /** @type {Collection<FeatureType>} */\n    let collection;\n    /** @type {Array<FeatureType>} */\n    let features;\n    if (Array.isArray(options.features)) {\n      features = options.features;\n    } else if (options.features) {\n      collection = options.features;\n      features = collection.getArray();\n    }\n    if (!useSpatialIndex && collection === undefined) {\n      collection = new Collection(features);\n    }\n    if (features !== undefined) {\n      this.addFeaturesInternal(features);\n    }\n    if (collection !== undefined) {\n      this.bindFeaturesCollection_(collection);\n    }\n  }\n\n  /**\n   * Add a single feature to the source.  If you want to add a batch of features\n   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}\n   * instead. A feature will not be added to the source if feature with\n   * the same id is already there. The reason for this behavior is to avoid\n   * feature duplication when using bbox or tile loading strategies.\n   * Note: this also applies if a {@link module:ol/Collection~Collection} is used for features,\n   * meaning that if a feature with a duplicate id is added in the collection, it will\n   * be removed from it right away.\n   * @param {FeatureType} feature Feature to add.\n   * @api\n   */\n  addFeature(feature) {\n    this.addFeatureInternal(feature);\n    this.changed();\n  }\n\n  /**\n   * Add a feature without firing a `change` event.\n   * @param {FeatureType} feature Feature.\n   * @protected\n   */\n  addFeatureInternal(feature) {\n    const featureKey = getUid(feature);\n\n    if (!this.addToIndex_(featureKey, feature)) {\n      if (this.featuresCollection_) {\n        this.featuresCollection_.remove(feature);\n      }\n      return;\n    }\n\n    this.setupChangeEvents_(featureKey, feature);\n\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const extent = geometry.getExtent();\n      if (this.featuresRtree_) {\n        this.featuresRtree_.insert(extent, feature);\n      }\n    } else {\n      this.nullGeometryFeatures_[featureKey] = feature;\n    }\n\n    this.dispatchEvent(\n      new VectorSourceEvent(VectorEventType.ADDFEATURE, feature),\n    );\n  }\n\n  /**\n   * @param {string} featureKey Unique identifier for the feature.\n   * @param {FeatureType} feature The feature.\n   * @private\n   */\n  setupChangeEvents_(featureKey, feature) {\n    if (feature instanceof RenderFeature) {\n      return;\n    }\n    this.featureChangeKeys_[featureKey] = [\n      listen(feature, EventType.CHANGE, this.handleFeatureChange_, this),\n      listen(\n        feature,\n        ObjectEventType.PROPERTYCHANGE,\n        this.handleFeatureChange_,\n        this,\n      ),\n    ];\n  }\n\n  /**\n   * @param {string} featureKey Unique identifier for the feature.\n   * @param {FeatureType} feature The feature.\n   * @return {boolean} The feature is \"valid\", in the sense that it is also a\n   *     candidate for insertion into the Rtree.\n   * @private\n   */\n  addToIndex_(featureKey, feature) {\n    let valid = true;\n    if (feature.getId() !== undefined) {\n      const id = String(feature.getId());\n      if (!(id in this.idIndex_)) {\n        this.idIndex_[id] = feature;\n      } else if (feature instanceof RenderFeature) {\n        const indexedFeature = this.idIndex_[id];\n        if (!(indexedFeature instanceof RenderFeature)) {\n          valid = false;\n        } else {\n          if (!Array.isArray(indexedFeature)) {\n            this.idIndex_[id] = [indexedFeature, feature];\n          } else {\n            indexedFeature.push(feature);\n          }\n        }\n      } else {\n        valid = false;\n      }\n    }\n    if (valid) {\n      assert(\n        !(featureKey in this.uidIndex_),\n        'The passed `feature` was already added to the source',\n      );\n      this.uidIndex_[featureKey] = feature;\n    }\n    return valid;\n  }\n\n  /**\n   * Add a batch of features to the source.\n   * @param {Array<FeatureType>} features Features to add.\n   * @api\n   */\n  addFeatures(features) {\n    this.addFeaturesInternal(features);\n    this.changed();\n  }\n\n  /**\n   * Add features without firing a `change` event.\n   * @param {Array<FeatureType>} features Features.\n   * @protected\n   */\n  addFeaturesInternal(features) {\n    const extents = [];\n    /** @type {Array<FeatureType>} */\n    const newFeatures = [];\n    /** @type {Array<FeatureType>} */\n    const geometryFeatures = [];\n\n    for (let i = 0, length = features.length; i < length; i++) {\n      const feature = features[i];\n      const featureKey = getUid(feature);\n      if (this.addToIndex_(featureKey, feature)) {\n        newFeatures.push(feature);\n      }\n    }\n\n    for (let i = 0, length = newFeatures.length; i < length; i++) {\n      const feature = newFeatures[i];\n      const featureKey = getUid(feature);\n      this.setupChangeEvents_(featureKey, feature);\n\n      const geometry = feature.getGeometry();\n      if (geometry) {\n        const extent = geometry.getExtent();\n        extents.push(extent);\n        geometryFeatures.push(feature);\n      } else {\n        this.nullGeometryFeatures_[featureKey] = feature;\n      }\n    }\n    if (this.featuresRtree_) {\n      this.featuresRtree_.load(extents, geometryFeatures);\n    }\n\n    if (this.hasListener(VectorEventType.ADDFEATURE)) {\n      for (let i = 0, length = newFeatures.length; i < length; i++) {\n        this.dispatchEvent(\n          new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i]),\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {!Collection<FeatureType>} collection Collection.\n   * @private\n   */\n  bindFeaturesCollection_(collection) {\n    let modifyingCollection = false;\n    this.addEventListener(\n      VectorEventType.ADDFEATURE,\n      /**\n       * @param {VectorSourceEvent<FeatureType>} evt The vector source event\n       */\n      function (evt) {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          collection.push(evt.feature);\n          modifyingCollection = false;\n        }\n      },\n    );\n    this.addEventListener(\n      VectorEventType.REMOVEFEATURE,\n      /**\n       * @param {VectorSourceEvent<FeatureType>} evt The vector source event\n       */\n      function (evt) {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          collection.remove(evt.feature);\n          modifyingCollection = false;\n        }\n      },\n    );\n    collection.addEventListener(\n      CollectionEventType.ADD,\n      /**\n       * @param {import(\"../Collection.js\").CollectionEvent<FeatureType>} evt The collection event\n       */\n      (evt) => {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          this.addFeature(evt.element);\n          modifyingCollection = false;\n        }\n      },\n    );\n    collection.addEventListener(\n      CollectionEventType.REMOVE,\n      /**\n       * @param {import(\"../Collection.js\").CollectionEvent<FeatureType>} evt The collection event\n       */\n      (evt) => {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          this.removeFeature(evt.element);\n          modifyingCollection = false;\n        }\n      },\n    );\n    this.featuresCollection_ = collection;\n  }\n\n  /**\n   * Remove all features from the source.\n   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.\n   * @api\n   */\n  clear(fast) {\n    if (fast) {\n      for (const featureId in this.featureChangeKeys_) {\n        const keys = this.featureChangeKeys_[featureId];\n        keys.forEach(unlistenByKey);\n      }\n      if (!this.featuresCollection_) {\n        this.featureChangeKeys_ = {};\n        this.idIndex_ = {};\n        this.uidIndex_ = {};\n      }\n    } else {\n      if (this.featuresRtree_) {\n        const removeAndIgnoreReturn = (feature) => {\n          this.removeFeatureInternal(feature);\n        };\n        this.featuresRtree_.forEach(removeAndIgnoreReturn);\n        for (const id in this.nullGeometryFeatures_) {\n          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);\n        }\n      }\n    }\n    if (this.featuresCollection_) {\n      this.featuresCollection_.clear();\n    }\n\n    if (this.featuresRtree_) {\n      this.featuresRtree_.clear();\n    }\n    this.nullGeometryFeatures_ = {};\n\n    const clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);\n    this.dispatchEvent(clearEvent);\n    this.changed();\n  }\n\n  /**\n   * Iterate through all features on the source, calling the provided callback\n   * with each one.  If the callback returns any \"truthy\" value, iteration will\n   * stop and the function will return the same value.\n   * Note: this function only iterate through the feature that have a defined geometry.\n   *\n   * @param {function(FeatureType): T} callback Called with each feature\n   *     on the source.  Return a truthy value to stop iteration.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n  forEachFeature(callback) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.forEach(callback);\n    }\n    if (this.featuresCollection_) {\n      this.featuresCollection_.forEach(callback);\n    }\n  }\n\n  /**\n   * Iterate through all features whose geometries contain the provided\n   * coordinate, calling the callback with each feature.  If the callback returns\n   * a \"truthy\" value, iteration will stop and the function will return the same\n   * value.\n   *\n   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be\n   * called for all features.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(FeatureType): T} callback Called with each feature\n   *     whose goemetry contains the provided coordinate.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   */\n  forEachFeatureAtCoordinateDirect(coordinate, callback) {\n    const extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];\n    return this.forEachFeatureInExtent(extent, function (feature) {\n      const geometry = feature.getGeometry();\n      if (\n        geometry instanceof RenderFeature ||\n        geometry.intersectsCoordinate(coordinate)\n      ) {\n        return callback(feature);\n      }\n      return undefined;\n    });\n  }\n\n  /**\n   * Iterate through all features whose bounding box intersects the provided\n   * extent (note that the feature's geometry may not intersect the extent),\n   * calling the callback with each feature.  If the callback returns a \"truthy\"\n   * value, iteration will stop and the function will return the same value.\n   *\n   * If you are interested in features whose geometry intersects an extent, call\n   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.\n   *\n   * When `useSpatialIndex` is set to false, this method will loop through all\n   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {function(FeatureType): T} callback Called with each feature\n   *     whose bounding box intersects the provided extent.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n  forEachFeatureInExtent(extent, callback) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.forEachInExtent(extent, callback);\n    }\n    if (this.featuresCollection_) {\n      this.featuresCollection_.forEach(callback);\n    }\n  }\n\n  /**\n   * Iterate through all features whose geometry intersects the provided extent,\n   * calling the callback with each feature.  If the callback returns a \"truthy\"\n   * value, iteration will stop and the function will return the same value.\n   *\n   * If you only want to test for bounding box intersection, call the\n   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {function(FeatureType): T} callback Called with each feature\n   *     whose geometry intersects the provided extent.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n  forEachFeatureIntersectingExtent(extent, callback) {\n    return this.forEachFeatureInExtent(\n      extent,\n      /**\n       * @param {FeatureType} feature Feature.\n       * @return {T|undefined} The return value from the last call to the callback.\n       */\n      function (feature) {\n        const geometry = feature.getGeometry();\n        if (\n          geometry instanceof RenderFeature ||\n          geometry.intersectsExtent(extent)\n        ) {\n          const result = callback(feature);\n          if (result) {\n            return result;\n          }\n        }\n      },\n    );\n  }\n\n  /**\n   * Get the features collection associated with this source. Will be `null`\n   * unless the source was configured with `useSpatialIndex` set to `false`, or\n   * with a {@link module:ol/Collection~Collection} as `features`.\n   * @return {Collection<FeatureType>|null} The collection of features.\n   * @api\n   */\n  getFeaturesCollection() {\n    return this.featuresCollection_;\n  }\n\n  /**\n   * Get a snapshot of the features currently on the source in random order. The returned array\n   * is a copy, the features are references to the features in the source.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeatures() {\n    let features;\n    if (this.featuresCollection_) {\n      features = this.featuresCollection_.getArray().slice(0);\n    } else if (this.featuresRtree_) {\n      features = this.featuresRtree_.getAll();\n      if (!isEmpty(this.nullGeometryFeatures_)) {\n        extend(features, Object.values(this.nullGeometryFeatures_));\n      }\n    }\n    return features;\n  }\n\n  /**\n   * Get all features whose geometry intersects the provided coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  getFeaturesAtCoordinate(coordinate) {\n    const features = [];\n    this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {\n      features.push(feature);\n    });\n    return features;\n  }\n\n  /**\n   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of\n   * all features intersecting the given extent in random order (so it may include\n   * features whose geometries do not intersect the extent).\n   *\n   * When `useSpatialIndex` is set to false, this method will return all\n   * features.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Include features\n   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeaturesInExtent(extent, projection) {\n    if (this.featuresRtree_) {\n      const multiWorld = projection && projection.canWrapX() && this.getWrapX();\n\n      if (!multiWorld) {\n        return this.featuresRtree_.getInExtent(extent);\n      }\n\n      const extents = wrapAndSliceX(extent, projection);\n\n      return [].concat(\n        ...extents.map((anExtent) => this.featuresRtree_.getInExtent(anExtent)),\n      );\n    }\n    if (this.featuresCollection_) {\n      return this.featuresCollection_.getArray().slice(0);\n    }\n    return [];\n  }\n\n  /**\n   * Get the closest feature to the provided coordinate.\n   *\n   * This method is not available when the source is configured with\n   * `useSpatialIndex` set to `false` and the features in this source are of type\n   * {@link module:ol/Feature~Feature}.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(FeatureType):boolean} [filter] Feature filter function.\n   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}\n   *     and it should return a boolean value. By default, no filtering is made.\n   * @return {FeatureType} Closest feature.\n   * @api\n   */\n  getClosestFeatureToCoordinate(coordinate, filter) {\n    // Find the closest feature using branch and bound.  We start searching an\n    // infinite extent, and find the distance from the first feature found.  This\n    // becomes the closest feature.  We then compute a smaller extent which any\n    // closer feature must intersect.  We continue searching with this smaller\n    // extent, trying to find a closer feature.  Every time we find a closer\n    // feature, we update the extent being searched so that any even closer\n    // feature must intersect it.  We continue until we run out of features.\n    const x = coordinate[0];\n    const y = coordinate[1];\n    let closestFeature = null;\n    const closestPoint = [NaN, NaN];\n    let minSquaredDistance = Infinity;\n    const extent = [-Infinity, -Infinity, Infinity, Infinity];\n    filter = filter ? filter : TRUE;\n    this.featuresRtree_.forEachInExtent(\n      extent,\n      /**\n       * @param {FeatureType} feature Feature.\n       */\n      function (feature) {\n        if (filter(feature)) {\n          const geometry = feature.getGeometry();\n          const previousMinSquaredDistance = minSquaredDistance;\n          minSquaredDistance =\n            geometry instanceof RenderFeature\n              ? 0\n              : geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);\n          if (minSquaredDistance < previousMinSquaredDistance) {\n            closestFeature = feature;\n            // This is sneaky.  Reduce the extent that it is currently being\n            // searched while the R-Tree traversal using this same extent object\n            // is still in progress.  This is safe because the new extent is\n            // strictly contained by the old extent.\n            const minDistance = Math.sqrt(minSquaredDistance);\n            extent[0] = x - minDistance;\n            extent[1] = y - minDistance;\n            extent[2] = x + minDistance;\n            extent[3] = y + minDistance;\n          }\n        }\n      },\n    );\n    return closestFeature;\n  }\n\n  /**\n   * Get the extent of the features currently in the source.\n   *\n   * This method is not available when the source is configured with\n   * `useSpatialIndex` set to `false`.\n   * @param {import(\"../extent.js\").Extent} [extent] Destination extent. If provided, no new extent\n   *     will be created. Instead, that extent's coordinates will be overwritten.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent(extent) {\n    return this.featuresRtree_.getExtent(extent);\n  }\n\n  /**\n   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s\n   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling\n   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per\n   * `GeometryCollection` member.\n   * Note that the index treats string and numeric identifiers as the same.  So\n   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.\n   *\n   * @param {string|number} id Feature identifier.\n   * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).\n   * @api\n   */\n  getFeatureById(id) {\n    const feature = this.idIndex_[id.toString()];\n    return feature !== undefined\n      ? /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */ (\n          feature\n        )\n      : null;\n  }\n\n  /**\n   * Get a feature by its internal unique identifier (using `getUid`).\n   *\n   * @param {string} uid Feature identifier.\n   * @return {FeatureType|null} The feature (or `null` if not found).\n   */\n  getFeatureByUid(uid) {\n    const feature = this.uidIndex_[uid];\n    return feature !== undefined ? feature : null;\n  }\n\n  /**\n   * Get the format associated with this source.\n   *\n   * @return {import(\"../format/Feature.js\").default<FeatureType>|null}} The feature format.\n   * @api\n   */\n  getFormat() {\n    return this.format_;\n  }\n\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  getOverlaps() {\n    return this.overlaps_;\n  }\n\n  /**\n   * Get the url associated with this source.\n   *\n   * @return {string|import(\"../featureloader.js\").FeatureUrlFunction|undefined} The url.\n   * @api\n   */\n  getUrl() {\n    return this.url_;\n  }\n\n  /**\n   * @param {Event} event Event.\n   * @private\n   */\n  handleFeatureChange_(event) {\n    const feature = /** @type {FeatureType} */ (event.target);\n    const featureKey = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (!geometry) {\n      if (!(featureKey in this.nullGeometryFeatures_)) {\n        if (this.featuresRtree_) {\n          this.featuresRtree_.remove(feature);\n        }\n        this.nullGeometryFeatures_[featureKey] = feature;\n      }\n    } else {\n      const extent = geometry.getExtent();\n      if (featureKey in this.nullGeometryFeatures_) {\n        delete this.nullGeometryFeatures_[featureKey];\n        if (this.featuresRtree_) {\n          this.featuresRtree_.insert(extent, feature);\n        }\n      } else {\n        if (this.featuresRtree_) {\n          this.featuresRtree_.update(extent, feature);\n        }\n      }\n    }\n    const id = feature.getId();\n    if (id !== undefined) {\n      const sid = id.toString();\n      if (this.idIndex_[sid] !== feature) {\n        this.removeFromIdIndex_(feature);\n        this.idIndex_[sid] = feature;\n      }\n    } else {\n      this.removeFromIdIndex_(feature);\n      this.uidIndex_[featureKey] = feature;\n    }\n    this.changed();\n    this.dispatchEvent(\n      new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature),\n    );\n  }\n\n  /**\n   * Returns true if the feature is contained within the source.\n   * @param {FeatureType} feature Feature.\n   * @return {boolean} Has feature.\n   * @api\n   */\n  hasFeature(feature) {\n    const id = feature.getId();\n    if (id !== undefined) {\n      return id in this.idIndex_;\n    }\n    return getUid(feature) in this.uidIndex_;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    if (this.featuresRtree_) {\n      return (\n        this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_)\n      );\n    }\n    if (this.featuresCollection_) {\n      return this.featuresCollection_.getLength() === 0;\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  loadFeatures(extent, resolution, projection) {\n    const loadedExtentsRtree = this.loadedExtentsRtree_;\n    const extentsToLoad = this.strategy_(extent, resolution, projection);\n    for (let i = 0, ii = extentsToLoad.length; i < ii; ++i) {\n      const extentToLoad = extentsToLoad[i];\n      const alreadyLoaded = loadedExtentsRtree.forEachInExtent(\n        extentToLoad,\n        /**\n         * @param {{extent: import(\"../extent.js\").Extent}} object Object.\n         * @return {boolean} Contains.\n         */\n        function (object) {\n          return containsExtent(object.extent, extentToLoad);\n        },\n      );\n      if (!alreadyLoaded) {\n        ++this.loadingExtentsCount_;\n        this.dispatchEvent(\n          new VectorSourceEvent(VectorEventType.FEATURESLOADSTART),\n        );\n        this.loader_.call(\n          this,\n          extentToLoad,\n          resolution,\n          projection,\n          (features) => {\n            --this.loadingExtentsCount_;\n            this.dispatchEvent(\n              new VectorSourceEvent(\n                VectorEventType.FEATURESLOADEND,\n                undefined,\n                features,\n              ),\n            );\n          },\n          () => {\n            --this.loadingExtentsCount_;\n            this.dispatchEvent(\n              new VectorSourceEvent(VectorEventType.FEATURESLOADERROR),\n            );\n          },\n        );\n        loadedExtentsRtree.insert(extentToLoad, {extent: extentToLoad.slice()});\n      }\n    }\n    this.loading =\n      this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;\n  }\n\n  /**\n   * @override\n   */\n  refresh() {\n    this.clear(true);\n    this.loadedExtentsRtree_.clear();\n    super.refresh();\n  }\n\n  /**\n   * Remove an extent from the list of loaded extents.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  removeLoadedExtent(extent) {\n    const loadedExtentsRtree = this.loadedExtentsRtree_;\n    let obj;\n    loadedExtentsRtree.forEachInExtent(extent, function (object) {\n      if (equals(object.extent, extent)) {\n        obj = object;\n        return true;\n      }\n    });\n    if (obj) {\n      loadedExtentsRtree.remove(obj);\n    }\n  }\n\n  /**\n   * Batch remove features from the source.  If you want to remove all features\n   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method\n   * instead.\n   * @param {Array<FeatureType>} features Features to remove.\n   * @api\n   */\n  removeFeatures(features) {\n    let removed = false;\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      removed = this.removeFeatureInternal(features[i]) || removed;\n    }\n    if (removed) {\n      this.changed();\n    }\n  }\n\n  /**\n   * Remove a single feature from the source. If you want to batch remove\n   * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method\n   * instead.\n   * @param {FeatureType} feature Feature to remove.\n   * @api\n   */\n  removeFeature(feature) {\n    if (!feature) {\n      return;\n    }\n    const removed = this.removeFeatureInternal(feature);\n    if (removed) {\n      this.changed();\n    }\n  }\n\n  /**\n   * Remove feature without firing a `change` event.\n   * @param {FeatureType} feature Feature.\n   * @return {boolean} True if the feature was removed, false if it was not found.\n   * @protected\n   */\n  removeFeatureInternal(feature) {\n    const featureKey = getUid(feature);\n    if (!(featureKey in this.uidIndex_)) {\n      return false;\n    }\n\n    if (featureKey in this.nullGeometryFeatures_) {\n      delete this.nullGeometryFeatures_[featureKey];\n    } else {\n      if (this.featuresRtree_) {\n        this.featuresRtree_.remove(feature);\n      }\n    }\n\n    const featureChangeKeys = this.featureChangeKeys_[featureKey];\n    featureChangeKeys?.forEach(unlistenByKey);\n    delete this.featureChangeKeys_[featureKey];\n\n    const id = feature.getId();\n    if (id !== undefined) {\n      const idString = id.toString();\n      const indexedFeature = this.idIndex_[idString];\n      if (indexedFeature === feature) {\n        delete this.idIndex_[idString];\n      } else if (Array.isArray(indexedFeature)) {\n        indexedFeature.splice(indexedFeature.indexOf(feature), 1);\n        if (indexedFeature.length === 1) {\n          this.idIndex_[idString] = indexedFeature[0];\n        }\n      }\n    }\n    delete this.uidIndex_[featureKey];\n    if (this.hasListener(VectorEventType.REMOVEFEATURE)) {\n      this.dispatchEvent(\n        new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature),\n      );\n    }\n    return true;\n  }\n\n  /**\n   * Remove a feature from the id index.  Called internally when the feature id\n   * may have changed.\n   * @param {FeatureType} feature The feature.\n   * @private\n   */\n  removeFromIdIndex_(feature) {\n    for (const id in this.idIndex_) {\n      if (this.idIndex_[id] === feature) {\n        delete this.idIndex_[id];\n        break;\n      }\n    }\n  }\n\n  /**\n   * Set the new loader of the source. The next render cycle will use the\n   * new loader.\n   * @param {import(\"../featureloader.js\").FeatureLoader<FeatureType>} loader The loader to set.\n   * @api\n   */\n  setLoader(loader) {\n    this.loader_ = loader;\n  }\n\n  /**\n   * Points the source to a new url. The next render cycle will use the new url.\n   * @param {string|import(\"../featureloader.js\").FeatureUrlFunction} url Url.\n   * @api\n   */\n  setUrl(url) {\n    assert(this.format_, '`format` must be set when `url` is set');\n    this.url_ = url;\n    this.setLoader(xhr(url, this.format_));\n  }\n}\n\nexport default VectorSource;\n", "/**\n * @module ol/structs/LRUCache\n */\n\nimport Disposable from '../Disposable.js';\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Entry|null} newer Newer.\n * @property {Entry|null} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [highWaterMark] High water mark.\n   */\n  constructor(highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},\n   * the entry will be disposed.\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n   */\n  expireCache(keep) {\n    while (this.canExpireCache()) {\n      const entry = this.pop();\n      if (entry instanceof Disposable) {\n        entry.dispose();\n      }\n    }\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    this.count_ = 0;\n    this.entries_ = {};\n    this.oldest_ = null;\n    this.newest_ = null;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, options) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      return entry.value_;\n    }\n    if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * Return an entry without updating least recently used time.\n   * @param {string} key Key.\n   * @return {T|undefined} Value.\n   */\n  peek(key) {\n    return this.entries_[key]?.value_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    assert(\n      !(key in this.entries_),\n      'Tried to set a value for a key that is used already',\n    );\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value,\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\n\nexport default LRUCache;\n", "/**\n * @module ol/layer/BaseImage\n */\nimport Layer from './Layer.js';\n\n/**\n * @template {import(\"../source/Image.js\").default} ImageSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {ImageSourceType} [source] Source for this layer.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Server-rendered images that are available for arbitrary extents and\n * resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Image.js\").default} ImageSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<ImageSourceType, RendererType>}\n * @api\n */\nclass BaseImageLayer extends Layer {\n  /**\n   * @param {Options<ImageSourceType>} [options] Layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super(options);\n  }\n}\n\nexport default BaseImageLayer;\n", "/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport {abstract} from '../util.js';\n\nconst maxStaleKeys = 5;\n\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nclass LayerRenderer extends Observable {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super();\n\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    this.ready = true;\n\n    /** @private */\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {LayerType}\n     */\n    this.layer_ = layer;\n\n    /**\n     * @type {Array<string>}\n     * @private\n     */\n    this.staleKeys_ = new Array();\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.maxStaleKeys = maxStaleKeys;\n  }\n\n  /**\n   * @return {Array<string>} Get the list of stale keys.\n   */\n  getStaleKeys() {\n    return this.staleKeys_;\n  }\n\n  /**\n   * @param {string} key The new stale key.\n   */\n  prependStaleKey(key) {\n    this.staleKeys_.unshift(key);\n    if (this.staleKeys_.length > this.maxStaleKeys) {\n      this.staleKeys_.length = this.maxStaleKeys;\n    }\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return abstract();\n  }\n\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement|null} target Target that may be used to render content to.\n   * @return {HTMLElement|null} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    return undefined;\n  }\n\n  /**\n   * @return {LayerType} Layer.\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n  handleFontsChanged() {}\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    if (\n      image.getState() === ImageState.LOADED ||\n      image.getState() === ImageState.ERROR\n    ) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../Image.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\n   * @protected\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeferred(frameState) {}\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n}\n\nexport default LayerRenderer;\n", "/**\n * @module ol/render/canvas/ZIndexContext\n */\n\nimport {getSharedCanvasContext2D} from '../../dom.js';\n\n/** @typedef {CanvasRenderingContext2D & {globalAlpha: any}} ZIndexContextProxy */\n\n/**\n * @extends {CanvasRenderingContext2D}\n */\nclass ZIndexContext {\n  constructor() {\n    /**\n     * @private\n     * @type {Array<Array<*>>}\n     */\n    this.instructions_ = [];\n    /**\n     * @type {number}\n     */\n    this.zIndex = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.offset_ = 0;\n\n    /**\n     * @private\n     * @type {ZIndexContextProxy}\n     */\n    this.context_ = /** @type {ZIndexContextProxy} */ (\n      new Proxy(getSharedCanvasContext2D(), {\n        get: (target, property) => {\n          if (\n            typeof (/** @type {*} */ (getSharedCanvasContext2D())[property]) !==\n            'function'\n          ) {\n            // we only accept calling functions on the proxy, not accessing properties\n            return undefined;\n          }\n          if (!this.instructions_[this.zIndex + this.offset_]) {\n            this.instructions_[this.zIndex + this.offset_] = [];\n          }\n          this.instructions_[this.zIndex + this.offset_].push(property);\n          return this.pushMethodArgs_;\n        },\n        set: (target, property, value) => {\n          if (!this.instructions_[this.zIndex + this.offset_]) {\n            this.instructions_[this.zIndex + this.offset_] = [];\n          }\n          this.instructions_[this.zIndex + this.offset_].push(property, value);\n          return true;\n        },\n      })\n    );\n  }\n\n  /**\n   * @private\n   * @param {...*} args Args.\n   * @return {ZIndexContext} This.\n   */\n  pushMethodArgs_ = (...args) => {\n    this.instructions_[this.zIndex + this.offset_].push(args);\n    return this;\n  };\n\n  /**\n   * Push a function that renders to the context directly.\n   * @param {function(CanvasRenderingContext2D): void} render Function.\n   */\n  pushFunction(render) {\n    this.instructions_[this.zIndex + this.offset_].push(render);\n  }\n\n  /**\n   * Get a proxy for CanvasRenderingContext2D which does not support getting state\n   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a\n   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,\n   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.\n   * @return {ZIndexContextProxy} Context.\n   */\n  getContext() {\n    return this.context_;\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n  draw(context) {\n    this.instructions_.forEach((instructionsAtIndex) => {\n      for (let i = 0, ii = instructionsAtIndex.length; i < ii; ++i) {\n        const property = instructionsAtIndex[i];\n        if (typeof property === 'function') {\n          property(context);\n          continue;\n        }\n        const instructionAtIndex = instructionsAtIndex[++i];\n        if (typeof (/** @type {*} */ (context)[property]) === 'function') {\n          /** @type {*} */ (context)[property](...instructionAtIndex);\n        } else {\n          if (typeof instructionAtIndex === 'function') {\n            /** @type {*} */ (context)[property] = instructionAtIndex(context);\n            continue;\n          }\n          /** @type {*} */ (context)[property] = instructionAtIndex;\n        }\n      }\n    });\n  }\n\n  clear() {\n    this.instructions_.length = 0;\n    this.zIndex = 0;\n    this.offset_ = 0;\n  }\n\n  /**\n   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to\n   * avoid conflicting context.clip() or context.save()/restore() calls.\n   */\n  offset() {\n    this.offset_ = this.instructions_.length;\n    this.zIndex = 0;\n  }\n}\n\nexport default ZIndexContext;\n", "/**\n * @module ol/renderer/canvas/Layer\n */\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  create as createTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {asArray} from '../../color.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {equals} from '../../array.js';\nimport {\n  getBottomLeft,\n  getBottomRight,\n  getHeight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n} from '../../extent.js';\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * @type {CanvasRenderingContext2D}\n */\nlet pixelContext = null;\n\nfunction createPixelContext() {\n  pixelContext = createCanvasContext2D(1, 1, undefined, {\n    willReadFrequently: true,\n  });\n}\n\n/**\n * @abstract\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass CanvasLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.container = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedResolution;\n\n    /**\n     * A temporary transform.  The values in this transform should only be used in a\n     * function that sets the values.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tempTransform = createTransform();\n\n    /**\n     * The transform for rendered pixels to viewport CSS pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.pixelTransform = createTransform();\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform = createTransform();\n\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = null;\n\n    /**\n     * @private\n     * @type {ZIndexContext}\n     */\n    this.deferredContext_ = null;\n\n    /**\n     * @type {boolean}\n     */\n    this.containerReused = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n  }\n\n  /**\n   * @param {import('../../DataTile.js').ImageLike} image Image.\n   * @param {number} col The column index.\n   * @param {number} row The row index.\n   * @return {Uint8ClampedArray|null} The image data.\n   */\n  getImageData(image, col, row) {\n    if (!pixelContext) {\n      createPixelContext();\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n\n    let data;\n    try {\n      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      pixelContext = null;\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * @param {import('../../Map.js').FrameState} frameState Frame state.\n   * @return {string} Background color.\n   */\n  getBackground(frameState) {\n    const layer = this.getLayer();\n    let background = layer.getBackground();\n    if (typeof background === 'function') {\n      background = background(frameState.viewState.resolution);\n    }\n    return background || undefined;\n  }\n\n  /**\n   * Get a rendering container from an existing target, if compatible.\n   * @param {HTMLElement} target Potential render target.\n   * @param {string} transform CSS Transform.\n   * @param {string} [backgroundColor] Background color.\n   */\n  useContainer(target, transform, backgroundColor) {\n    const layerClassName = this.getLayer().getClassName();\n    let container, context;\n    if (\n      target &&\n      target.className === layerClassName &&\n      (!backgroundColor ||\n        (target &&\n          target.style.backgroundColor &&\n          equals(\n            asArray(target.style.backgroundColor),\n            asArray(backgroundColor),\n          )))\n    ) {\n      const canvas = target.firstElementChild;\n      if (canvas instanceof HTMLCanvasElement) {\n        context = canvas.getContext('2d');\n      }\n    }\n    if (context && context.canvas.style.transform === transform) {\n      // Container of the previous layer renderer can be used.\n      this.container = target;\n      this.context = context;\n      this.containerReused = true;\n    } else if (this.containerReused) {\n      // Previously reused container cannot be used any more.\n      this.container = null;\n      this.context = null;\n      this.containerReused = false;\n    } else if (this.container) {\n      this.container.style.backgroundColor = null;\n    }\n    if (!this.container) {\n      container = document.createElement('div');\n      container.className = layerClassName;\n      let style = container.style;\n      style.position = 'absolute';\n      style.width = '100%';\n      style.height = '100%';\n      context = createCanvasContext2D();\n      const canvas = context.canvas;\n      container.appendChild(canvas);\n      style = canvas.style;\n      style.position = 'absolute';\n      style.left = '0';\n      style.transformOrigin = 'top left';\n      this.container = container;\n      this.context = context;\n    }\n    if (\n      !this.containerReused &&\n      backgroundColor &&\n      !this.container.style.backgroundColor\n    ) {\n      this.container.style.backgroundColor = backgroundColor;\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent Clip extent.\n   * @protected\n   */\n  clipUnrotated(context, frameState, extent) {\n    const topLeft = getTopLeft(extent);\n    const topRight = getTopRight(extent);\n    const bottomRight = getBottomRight(extent);\n    const bottomLeft = getBottomLeft(extent);\n\n    applyTransform(frameState.coordinateToPixelTransform, topLeft);\n    applyTransform(frameState.coordinateToPixelTransform, topRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomLeft);\n\n    const inverted = this.inversePixelTransform;\n    applyTransform(inverted, topLeft);\n    applyTransform(inverted, topRight);\n    applyTransform(inverted, bottomRight);\n    applyTransform(inverted, bottomLeft);\n\n    context.save();\n    context.beginPath();\n    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));\n    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));\n    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));\n    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));\n    context.clip();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @protected\n   */\n  prepareContainer(frameState, target) {\n    const extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2,\n    );\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n\n    if (!this.containerReused) {\n      const canvas = this.context.canvas;\n      if (canvas.width != width || canvas.height != height) {\n        canvas.width = width;\n        canvas.height = height;\n      } else {\n        this.context.clearRect(0, 0, width, height);\n      }\n      if (canvasTransform !== canvas.style.transform) {\n        canvas.style.transform = canvasTransform;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform,\n        frameState,\n        context,\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.frameState = frameState;\n    if (frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    if (frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeferredInternal(frameState) {}\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.\n   */\n  getRenderContext(frameState) {\n    if (frameState.declutter && !this.deferredContext_) {\n      this.deferredContext_ = new ZIndexContext();\n    }\n    return frameState.declutter\n      ? this.deferredContext_.getContext()\n      : this.context;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderDeferred(frameState) {\n    if (!frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(\n      RenderEventType.PRERENDER,\n      this.context,\n      frameState,\n    );\n    if (frameState.declutter && this.deferredContext_) {\n      this.deferredContext_.draw(this.context);\n      this.deferredContext_.clear();\n    }\n    this.renderDeferredInternal(frameState);\n    this.dispatchRenderEvent_(\n      RenderEventType.POSTRENDER,\n      this.context,\n      frameState,\n    );\n  }\n\n  /**\n   * Creates a transform for rendering to an element that will be rotated after rendering.\n   * @param {import(\"../../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} width Width of the rendered element (in pixels).\n   * @param {number} height Height of the rendered element (in pixels).\n   * @param {number} offsetX Offset on the x-axis in view coordinates.\n   * @protected\n   * @return {!import(\"../../transform.js\").Transform} Transform.\n   */\n  getRenderTransform(\n    center,\n    resolution,\n    rotation,\n    pixelRatio,\n    width,\n    height,\n    offsetX,\n  ) {\n    const dx1 = width / 2;\n    const dy1 = height / 2;\n    const sx = pixelRatio / resolution;\n    const sy = -sx;\n    const dx2 = -center[0] + offsetX;\n    const dy2 = -center[1];\n    return composeTransform(\n      this.tempTransform,\n      dx1,\n      dy1,\n      sx,\n      sy,\n      -rotation,\n      dx2,\n      dy2,\n    );\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    delete this.frameState;\n    super.disposeInternal();\n  }\n}\n\nexport default CanvasLayerRenderer;\n", "/**\n * @module ol/renderer/canvas/ImageLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageState from '../../ImageState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {\n  containsCoordinate,\n  containsExtent,\n  getHeight,\n  getIntersection,\n  getWidth,\n  intersects as intersectsExtent,\n  isEmpty,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasImageLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\n   */\n  constructor(imageLayer) {\n    super(imageLayer);\n\n    /**\n     * @protected\n     * @type {?import(\"../../Image.js\").default}\n     */\n    this.image = null;\n  }\n\n  /**\n   * @return {import('../../DataTile.js').ImageLike} Image.\n   */\n  getImage() {\n    return !this.image ? null : this.image.getImage();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n\n    const imageSource = this.getLayer().getSource();\n\n    const hints = frameState.viewHints;\n\n    let renderedExtent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      renderedExtent = getIntersection(\n        renderedExtent,\n        fromUserExtent(layerState.extent, viewState.projection),\n      );\n    }\n\n    if (\n      !hints[ViewHint.ANIMATING] &&\n      !hints[ViewHint.INTERACTING] &&\n      !isEmpty(renderedExtent)\n    ) {\n      if (imageSource) {\n        const projection = viewState.projection;\n        const image = imageSource.getImage(\n          renderedExtent,\n          viewResolution,\n          pixelRatio,\n          projection,\n        );\n        if (image) {\n          if (this.loadImage(image)) {\n            this.image = image;\n          } else if (image.getState() === ImageState.EMPTY) {\n            this.image = null;\n          }\n        }\n      } else {\n        this.image = null;\n      }\n    }\n\n    return !!this.image;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const imageExtent = this.image.getExtent();\n    const img = this.image.getImage();\n\n    const imageMapWidth = getWidth(imageExtent);\n    const col = Math.floor(\n      img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth),\n    );\n    if (col < 0 || col >= img.width) {\n      return null;\n    }\n\n    const imageMapHeight = getHeight(imageExtent);\n    const row = Math.floor(\n      img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight),\n    );\n    if (row < 0 || row >= img.height) {\n      return null;\n    }\n\n    return this.getImageData(img, col, row);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    const image = this.image;\n    const imageExtent = image.getExtent();\n    const imageResolution = image.getResolution();\n    const [imageResolutionX, imageResolutionY] = Array.isArray(imageResolution)\n      ? imageResolution\n      : [imageResolution, imageResolution];\n    const imagePixelRatio = image.getPixelRatio();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewCenter = viewState.center;\n    const viewResolution = viewState.resolution;\n    const scaleX =\n      (pixelRatio * imageResolutionX) / (viewResolution * imagePixelRatio);\n    const scaleY =\n      (pixelRatio * imageResolutionY) / (viewResolution * imagePixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const context = this.getRenderContext(frameState);\n\n    // clipped rendering if layer extent is set\n    let clipped = false;\n    let render = true;\n    if (layerState.extent) {\n      const layerExtent = fromUserExtent(\n        layerState.extent,\n        viewState.projection,\n      );\n      render = intersectsExtent(layerExtent, frameState.extent);\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    const img = image.getImage();\n\n    const transform = composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      scaleX,\n      scaleY,\n      0,\n      (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolutionX,\n      (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolutionY,\n    );\n\n    this.renderedResolution = (imageResolutionY * pixelRatio) / imagePixelRatio;\n\n    const dw = img.width * transform[0];\n    const dh = img.height * transform[3];\n\n    if (!this.getLayer().getSource().getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n    if (render && dw >= 0.5 && dh >= 0.5) {\n      const dx = transform[4];\n      const dy = transform[5];\n      const opacity = layerState.opacity;\n      if (opacity !== 1) {\n        context.save();\n        context.globalAlpha = opacity;\n      }\n      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);\n      if (opacity !== 1) {\n        context.restore();\n      }\n    }\n    this.postRender(this.context, frameState);\n\n    if (clipped) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    return this.container;\n  }\n}\n\nexport default CanvasImageLayerRenderer;\n", "/**\n * @module ol/layer/Image\n */\nimport BaseImageLayer from './BaseImage.js';\nimport CanvasImageLayerRenderer from '../renderer/canvas/ImageLayer.js';\n\n/**\n * @classdesc\n * Server-rendered images that are available for arbitrary extents and\n * resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Image.js\").default} ImageSourceType\n * @extends {BaseImageLayer<ImageSourceType, CanvasImageLayerRenderer>}\n * @api\n */\nclass ImageLayer extends BaseImageLayer {\n  /**\n   * @param {import(\"./BaseImage.js\").Options<ImageSourceType>} [options] Layer options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new CanvasImageLayerRenderer(this);\n  }\n\n  /**\n   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the\n   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the\n   * source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   * @override\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default ImageLayer;\n", "/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n", "/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {TileSourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n * @property {number} [cacheSize=512] The internal tile cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<TileSourceType, RendererType>}\n * @api\n */\nclass BaseTileLayer extends Layer {\n  /**\n   * @param {Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    const cacheSize = options.cacheSize;\n    delete options.cacheSize;\n\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    super(baseOptions);\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true,\n    );\n  }\n\n  /**\n   * @return {number|undefined} The suggested cache size\n   * @protected\n   */\n  getCacheSize() {\n    return this.cacheSize_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Deprecated.  Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Deprecated.  Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n\n  /**\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   * @override\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default BaseTileLayer;\n", "/**\n * @module ol/Tile\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport TileState from './TileState.js';\nimport {abstract} from './util.js';\nimport {easeIn} from './easing.js';\n\n/**\n * A function that takes a {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState.js';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   const xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     const data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes a {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * A key assigned to the tile. This is used in conjunction with a source key\n     * to determine if a cached version of this tile may be used by the renderer.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @private\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n    /**\n     * @type {boolean}\n     */\n    this.interpolate = !!options.interpolate;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {\n    if (this.state === TileState.ERROR) {\n      // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\n      this.setState(TileState.EMPTY);\n    }\n  }\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.release();\n    super.disposeInternal();\n  }\n}\n\nexport default Tile;\n", "/**\n * @module ol/DataTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\n\n/**\n * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike\n */\n\n/**\n * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike\n */\n\n/**\n * Data that can be used with a DataTile.\n * @typedef {ArrayLike|ImageLike} Data\n */\n\n/**\n * @param {Data} data Tile data.\n * @return {ImageLike|null} The image-like data.\n */\nexport function asImageLike(data) {\n  return data instanceof Image ||\n    data instanceof HTMLCanvasElement ||\n    data instanceof HTMLVideoElement ||\n    data instanceof ImageBitmap\n    ? data\n    : null;\n}\n\n/**\n * @param {Data} data Tile data.\n * @return {ArrayLike|null} The array-like data.\n */\nexport function asArrayLike(data) {\n  return data instanceof Uint8Array ||\n    data instanceof Uint8ClampedArray ||\n    data instanceof Float32Array ||\n    data instanceof DataView\n    ? data\n    : null;\n}\n\n/**\n * This is set as the cancellation reason when a tile is disposed.\n */\nexport const disposedError = new Error('disposed');\n\n/**\n * @type {CanvasRenderingContext2D|null}\n */\nlet sharedContext = null;\n\n/**\n * @param {ImageLike} image The image.\n * @return {Uint8ClampedArray} The data.\n */\nexport function toArray(image) {\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(\n      image.width,\n      image.height,\n      undefined,\n      {willReadFrequently: true},\n    );\n  }\n  const canvas = sharedContext.canvas;\n  const width = image.width;\n  if (canvas.width !== width) {\n    canvas.width = width;\n  }\n  const height = image.height;\n  if (canvas.height !== height) {\n    canvas.height = height;\n  }\n  sharedContext.clearRect(0, 0, width, height);\n  sharedContext.drawImage(image, 0, 0);\n  return sharedContext.getImageData(0, 0, width, height).data;\n}\n\n/**\n * @type {import('./size.js').Size}\n */\nconst defaultSize = [256, 256];\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,\n * the promise should not resolve until the image is loaded.\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {import('./size.js').Size} [size=[256, 256]] Tile size.\n * @property {AbortController} [controller] An abort controller.\n * @api\n */\n\nclass DataTile extends Tile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    const state = TileState.IDLE;\n\n    super(options.tileCoord, state, {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    });\n\n    /**\n     * @type {function(): Promise<Data>}\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @type {Data}\n     * @private\n     */\n    this.data_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {import('./size.js').Size|null}\n     * @private\n     */\n    this.size_ = options.size || null;\n\n    /**\n     * @type {AbortController|null}\n     * @private\n     */\n    this.controller_ = options.controller || null;\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('./size.js').Size} Tile size.\n   */\n  getSize() {\n    if (this.size_) {\n      return this.size_;\n    }\n    const imageData = asImageLike(this.data_);\n    if (imageData) {\n      return [imageData.width, imageData.height];\n    }\n    return defaultSize;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {Data} Tile data.\n   * @api\n   */\n  getData() {\n    return this.data_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @api\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Load the tile data.\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    const self = this;\n    this.loader_()\n      .then(function (data) {\n        self.data_ = data;\n        self.state = TileState.LOADED;\n        self.changed();\n      })\n      .catch(function (error) {\n        self.error_ = error;\n        self.state = TileState.ERROR;\n        self.changed();\n      });\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    if (this.controller_) {\n      this.controller_.abort(disposedError);\n      this.controller_ = null;\n    }\n    super.disposeInternal();\n  }\n}\n\nexport default DataTile;\n", "/**\n * @module ol/ImageTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {listenImage} from './Image.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n   */\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   *\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\n   * that checks for error status codes and reloads only when the status code is\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\n   * made already:\n   *\n   * ```js\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\n   * const retries = {};\n   * source.setTileLoadFunction((tile, src) => {\n   *   const image = tile.getImage();\n   *   fetch(src)\n   *     .then((response) => {\n   *       if (retryCodes.includes(response.status)) {\n   *         retries[src] = (retries[src] || 0) + 1;\n   *         if (retries[src] <= 3) {\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\n   *         }\n   *         return Promise.reject();\n   *       }\n   *       return response.blob();\n   *     })\n   *     .then((blob) => {\n   *       const imageUrl = URL.createObjectURL(blob);\n   *       image.src = imageUrl;\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\n   *     })\n   *     .catch(() => tile.setState(3)); // error\n   * });\n   * ```\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this),\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.unlistenImage_();\n    this.image_ = null;\n    super.disposeInternal();\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n", "/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport const ERROR_THRESHOLD = 0.5;\n", "/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {getTransform} from '../proj.js';\nimport {modulo} from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    destinationResolution,\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overall reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              Math.log2(\n                getArea(targetExtent) /\n                  (destinationResolution * destinationResolution * 256 * 256),\n              ),\n            ),\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision,\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0],\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach((triangle) => {\n        if (\n          Math.max(\n            triangle.source[0][0],\n            triangle.source[1][0],\n            triangle.source[2][0],\n          ) -\n            leftBound >\n          this.sourceWorldWidth_ / 2\n        ) {\n          const newTriangle = [\n            [triangle.source[0][0], triangle.source[0][1]],\n            [triangle.source[1][0], triangle.source[1][1]],\n            [triangle.source[2][0], triangle.source[2][1]],\n          ];\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          const minX = Math.min(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0],\n          );\n          const maxX = Math.max(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0],\n          );\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1,\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1,\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1,\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1,\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n", "/**\n * @module ol/reproj\n */\nimport {\n  containsCoordinate,\n  createEmpty,\n  extend,\n  forEachCorner,\n  getCenter,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from './extent.js';\nimport {createCanvasContext2D, releaseCanvas} from './dom.js';\nimport {getPointResolution, transform} from './proj.js';\nimport {solveLinearSystem} from './math.js';\n\nlet brokenDiagonalRendering_;\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\n\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\n  return (\n    Math.abs(data[offset * 4] - 210) > 2 ||\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\n  );\n}\n\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === undefined) {\n    const ctx = createCanvasContext2D(6, 6, canvasPool);\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    const data = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ =\n      verifyBrokenDiagonalRendering(data, 0) ||\n      verifyBrokenDiagonalRendering(data, 4) ||\n      verifyBrokenDiagonalRendering(data, 8);\n    releaseCanvas(ctx);\n    canvasPool.push(ctx.canvas);\n  }\n\n  return brokenDiagonalRendering_;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(\n  sourceProj,\n  targetProj,\n  targetCenter,\n  targetResolution,\n) {\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  let sourceResolution = getPointResolution(\n    targetProj,\n    targetResolution,\n    targetCenter,\n  );\n\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  const sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    const compensationFactor =\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n      sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(\n  sourceProj,\n  targetProj,\n  targetExtent,\n  targetResolution,\n) {\n  const targetCenter = getCenter(targetExtent);\n  let sourceResolution = calculateSourceResolution(\n    sourceProj,\n    targetProj,\n    targetCenter,\n    targetResolution,\n  );\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    forEachCorner(targetExtent, function (corner) {\n      sourceResolution = calculateSourceResolution(\n        sourceProj,\n        targetProj,\n        corner,\n        targetResolution,\n      );\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n\n  return sourceResolution;\n}\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"./extent.js\").Extent} extent Extent.\n * @property {import(\"./extent.js\").Extent} [clipExtent] Clip extent.\n * @property {import('./DataTile.js').ImageLike} image Image.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @param {boolean} [drawSingle] Draw single source images directly without stitchContext.\n * @param {boolean} [clipExtent] Clip stitchContext to sourceExtent.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(\n  width,\n  height,\n  pixelRatio,\n  sourceResolution,\n  sourceExtent,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  renderEdges,\n  interpolate,\n  drawSingle,\n  clipExtent,\n) {\n  const context = createCanvasContext2D(\n    Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height),\n    canvasPool,\n  );\n\n  if (!interpolate) {\n    context.imageSmoothingEnabled = false;\n  }\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n\n  context.globalCompositeOperation = 'lighter';\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  let stitchContext;\n  const stitchScale = pixelRatio / sourceResolution;\n  // Round up Float32 scale values to prevent interpolation in Firefox.\n  const inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;\n\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\n    stitchContext = createCanvasContext2D(\n      Math.round(getWidth(sourceDataExtent) * stitchScale),\n      Math.round(getHeight(sourceDataExtent) * stitchScale),\n      canvasPool,\n    );\n\n    if (!interpolate) {\n      stitchContext.imageSmoothingEnabled = false;\n    }\n    if (sourceExtent && clipExtent) {\n      const xPos = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale;\n      const yPos = -(sourceExtent[3] - sourceDataExtent[3]) * stitchScale;\n      const width = getWidth(sourceExtent) * stitchScale;\n      const height = getHeight(sourceExtent) * stitchScale;\n      stitchContext.rect(xPos, yPos, width, height);\n      stitchContext.clip();\n    }\n\n    sources.forEach(function (src, i, arr) {\n      // This test should never fail -- but it does. Need to find a fix the upstream condition\n      if (src.image.width > 0 && src.image.height > 0) {\n        if (src.clipExtent) {\n          stitchContext.save();\n          const xPos = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;\n          const yPos = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;\n          const width = getWidth(src.clipExtent) * stitchScale;\n          const height = getHeight(src.clipExtent) * stitchScale;\n          stitchContext.rect(\n            interpolate ? xPos : Math.round(xPos),\n            interpolate ? yPos : Math.round(yPos),\n            interpolate ? width : Math.round(xPos + width) - Math.round(xPos),\n            interpolate ? height : Math.round(yPos + height) - Math.round(yPos),\n          );\n          stitchContext.clip();\n        }\n\n        const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale;\n        const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;\n        const srcWidth = getWidth(src.extent) * stitchScale;\n        const srcHeight = getHeight(src.extent) * stitchScale;\n        stitchContext.drawImage(\n          src.image,\n          gutter,\n          gutter,\n          src.image.width - 2 * gutter,\n          src.image.height - 2 * gutter,\n          interpolate ? xPos : Math.round(xPos),\n          interpolate ? yPos : Math.round(yPos),\n          interpolate\n            ? srcWidth\n            : Math.round(xPos + srcWidth) - Math.round(xPos),\n          interpolate\n            ? srcHeight\n            : Math.round(yPos + srcHeight) - Math.round(yPos),\n        );\n\n        if (src.clipExtent) {\n          stitchContext.restore();\n        }\n      }\n    });\n  }\n  const targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    const source = triangle.source;\n    const target = triangle.target;\n    let x0 = source[0][0],\n      y0 = source[0][1];\n    let x1 = source[1][0],\n      y1 = source[1][1];\n    let x2 = source[2][0],\n      y2 = source[2][1];\n    // Make sure that everything is on pixel boundaries\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    const v0 = pixelRound(\n      -(target[0][1] - targetTopLeft[1]) / targetResolution,\n    );\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    const v1 = pixelRound(\n      -(target[1][1] - targetTopLeft[1]) / targetResolution,\n    );\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    const v2 = pixelRound(\n      -(target[2][1] - targetTopLeft[1]) / targetResolution,\n    );\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    const sourceNumericalShiftX = x0;\n    const sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    const augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0],\n    ];\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n\n    if (isBrokenDiagonalRendering() || !interpolate) {\n      // Make sure that all lines are horizontal or vertical\n      context.moveTo(u1, v1);\n      // This is the diagonal line. Do it in 4 steps\n      const steps = 4;\n      const ud = u0 - u1;\n      const vd = v0 - v1;\n      for (let step = 0; step < steps; step++) {\n        // Go horizontally\n        context.lineTo(\n          u1 + pixelRound(((step + 1) * ud) / steps),\n          v1 + pixelRound((step * vd) / (steps - 1)),\n        );\n        // Go vertically\n        if (step != steps - 1) {\n          context.lineTo(\n            u1 + pixelRound(((step + 1) * ud) / steps),\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1)),\n          );\n        }\n      }\n      // We are almost at u0r, v0r\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n\n    context.clip();\n\n    context.transform(\n      affineCoefs[0],\n      affineCoefs[2],\n      affineCoefs[1],\n      affineCoefs[3],\n      u0,\n      v0,\n    );\n\n    context.translate(\n      sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY,\n    );\n\n    let image;\n    if (stitchContext) {\n      image = stitchContext.canvas;\n      context.scale(inverseScale, -inverseScale);\n    } else {\n      const source = sources[0];\n      const extent = source.extent;\n      image = source.image;\n      context.scale(\n        getWidth(extent) / image.width,\n        -getHeight(extent) / image.height,\n      );\n    }\n\n    context.drawImage(image, 0, 0);\n    context.restore();\n  });\n\n  if (stitchContext) {\n    releaseCanvas(stitchContext);\n    canvasPool.push(stitchContext.canvas);\n  }\n\n  if (renderEdges) {\n    context.save();\n\n    context.globalCompositeOperation = 'source-over';\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const target = triangle.target;\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n", "/**\n * @module ol/reproj/DataTile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport DataTile, {asArrayLike, asImageLike, toArray} from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {createCanvasContext2D, releaseCanvas} from '../dom.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {DataTile} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\n * @property {number} pixelRatio Pixel ratio.\n * @property {number} gutter Gutter of the source tiles.\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected data tile.\n * See {@link module:ol/source/DataTile~DataTileSource}.\n *\n */\nclass ReprojDataTile extends DataTile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    super({\n      tileCoord: options.tileCoord,\n      loader: () => Promise.resolve(new Uint8ClampedArray(4)),\n      interpolate: options.interpolate,\n      transition: options.transition,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     * @private\n     */\n    this.reprojData_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.reprojError_ = null;\n\n    /**\n     * @type {import('../size.js').Size}\n     * @private\n     */\n    this.reprojSize_ = undefined;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = options.sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = options.targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const sourceProj = options.sourceProj;\n    const sourceProjExtent = sourceProj.getExtent();\n    const sourceTileGridExtent = options.sourceTileGrid.getExtent();\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceTileGridExtent\n        ? getIntersection(sourceProjExtent, sourceTileGridExtent)\n        : sourceProjExtent\n      : sourceTileGridExtent;\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = this.targetTileGrid_.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const targetProj = options.targetProj;\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      options.errorThreshold !== undefined\n        ? options.errorThreshold\n        : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n        const getTile = options.getTileFunction;\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('../size.js').Size} Tile size.\n   * @override\n   */\n  getSize() {\n    return this.reprojSize_;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {import(\"../DataTile.js\").Data} Tile data.\n   * @override\n   */\n  getData() {\n    return this.reprojData_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @override\n   */\n  getError() {\n    return this.reprojError_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const dataSources = [];\n    let imageLike = false;\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const size = tile.getSize();\n      const gutter = this.gutter_;\n      /**\n       * @type {import(\"../DataTile.js\").ArrayLike}\n       */\n      let tileData;\n      const arrayData = asArrayLike(tile.getData());\n      if (arrayData) {\n        tileData = arrayData;\n      } else {\n        imageLike = true;\n        tileData = toArray(asImageLike(tile.getData()));\n      }\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\n      const isFloat = tileData instanceof Float32Array;\n      const pixelCount = pixelSize[0] * pixelSize[1];\n      const DataType = isFloat ? Float32Array : Uint8ClampedArray;\n      const tileDataR = new DataType(tileData.buffer);\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n      const bytesPerPixel = (bytesPerElement * tileDataR.length) / pixelCount;\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\n      const bandCount = Math.floor(\n        bytesPerRow / bytesPerElement / pixelSize[0],\n      );\n      const packedLength = pixelCount * bandCount;\n      let packedData = tileDataR;\n      if (tileDataR.length !== packedLength) {\n        packedData = new DataType(packedLength);\n        let dataIndex = 0;\n        let rowOffset = 0;\n        const colCount = pixelSize[0] * bandCount;\n        for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\n          for (let colIndex = 0; colIndex < colCount; ++colIndex) {\n            packedData[dataIndex++] = tileDataR[rowOffset + colIndex];\n          }\n          rowOffset += bytesPerRow / bytesPerElement;\n        }\n      }\n      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n      extent[0] += source.offset;\n      extent[2] += source.offset;\n      const clipExtent = this.clipExtent_?.slice();\n      if (clipExtent) {\n        clipExtent[0] += source.offset;\n        clipExtent[2] += source.offset;\n      }\n      dataSources.push({\n        extent: extent,\n        clipExtent: clipExtent,\n        data: new Uint8ClampedArray(packedData.buffer),\n        dataType: DataType,\n        bytesPerPixel: bytesPerPixel,\n        pixelSize: pixelSize,\n      });\n    });\n    this.sourceTiles_.length = 0;\n\n    if (dataSources.length === 0) {\n      this.state = TileState.ERROR;\n      this.changed();\n      return;\n    }\n\n    const z = this.wrappedTileCoord_[0];\n    const size = this.targetTileGrid_.getTileSize(z);\n    const targetWidth = typeof size === 'number' ? size : size[0];\n    const targetHeight = typeof size === 'number' ? size : size[1];\n    const targetResolution = this.targetTileGrid_.getResolution(z);\n    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n\n    let dataR, dataU;\n\n    const bytesPerPixel = dataSources[0].bytesPerPixel;\n\n    const reprojs = Math.ceil(bytesPerPixel / 3);\n    for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\n      const sources = [];\n      for (let i = 0, len = dataSources.length; i < len; ++i) {\n        const dataSource = dataSources[i];\n        const buffer = dataSource.data;\n        const pixelSize = dataSource.pixelSize;\n        const width = pixelSize[0];\n        const height = pixelSize[1];\n        const context = createCanvasContext2D(width, height, canvasPool);\n        const imageData = context.createImageData(width, height);\n        const data = imageData.data;\n        let offset = reproj * 3;\n        for (let j = 0, len = data.length; j < len; j += 4) {\n          data[j] = buffer[offset];\n          data[j + 1] = buffer[offset + 1];\n          data[j + 2] = buffer[offset + 2];\n          data[j + 3] = 255;\n          offset += bytesPerPixel;\n        }\n        context.putImageData(imageData, 0, 0);\n        sources.push({\n          extent: dataSource.extent,\n          clipExtent: dataSource.clipExtent,\n          image: context.canvas,\n        });\n      }\n\n      const canvas = renderReprojected(\n        targetWidth,\n        targetHeight,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        false,\n        false,\n        false,\n      );\n\n      for (let i = 0, len = sources.length; i < len; ++i) {\n        const canvas = sources[i].image;\n        const context = canvas.getContext('2d');\n        releaseCanvas(context);\n        canvasPool.push(context.canvas);\n      }\n\n      const context = canvas.getContext('2d');\n      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n\n      releaseCanvas(context);\n      canvasPool.push(canvas);\n\n      if (!dataR) {\n        dataU = new Uint8ClampedArray(\n          bytesPerPixel * imageData.width * imageData.height,\n        );\n        dataR = new dataSources[0].dataType(dataU.buffer);\n      }\n\n      const data = imageData.data;\n      let offset = reproj * 3;\n      for (let i = 0, len = data.length; i < len; i += 4) {\n        if (data[i + 3] === 255) {\n          dataU[offset] = data[i];\n          dataU[offset + 1] = data[i + 1];\n          dataU[offset + 2] = data[i + 2];\n        } else {\n          dataU[offset] = 0;\n          dataU[offset + 1] = 0;\n          dataU[offset + 2] = 0;\n        }\n        offset += bytesPerPixel;\n      }\n    }\n\n    if (imageLike) {\n      const context = createCanvasContext2D(targetWidth, targetHeight);\n      const imageData = new ImageData(dataR, targetWidth);\n      context.putImageData(imageData, 0, 0);\n      this.reprojData_ = context.canvas;\n    } else {\n      this.reprojData_ = dataR;\n    }\n    this.reprojSize_ = [\n      Math.round(targetWidth * this.pixelRatio_),\n      Math.round(targetHeight * this.pixelRatio_),\n    ];\n    this.state = TileState.LOADED;\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    let leftToLoad = 0;\n\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach(({tile}) => {\n      const state = tile.getState();\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\n        return;\n      }\n      leftToLoad++;\n\n      const sourceListenKey = listen(tile, EventType.CHANGE, () => {\n        const state = tile.getState();\n        if (\n          state == TileState.LOADED ||\n          state == TileState.ERROR ||\n          state == TileState.EMPTY\n        ) {\n          unlistenByKey(sourceListenKey);\n          leftToLoad--;\n          if (leftToLoad === 0) {\n            this.unlistenSources_();\n            this.reproject_();\n          }\n        }\n      });\n      this.sourcesListenerKeys_.push(sourceListenKey);\n    });\n\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    } else {\n      this.sourceTiles_.forEach(function ({tile}) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\nexport default ReprojDataTile;\n", "/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {releaseCanvas} from '../dom.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {import(\"../ImageTile.js\").default} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    options,\n  ) {\n    super(tileCoord, TileState.IDLE, options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceProj.getExtent()\n      : undefined;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (tile && tile.getState() == TileState.LOADED) {\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n        extent[0] += source.offset;\n        extent[2] += source.offset;\n        const clipExtent = this.clipExtent_?.slice();\n        if (clipExtent) {\n          clipExtent[0] += source.offset;\n          clipExtent[2] += source.offset;\n        }\n        sources.push({\n          extent: extent,\n          clipExtent: clipExtent,\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_,\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_,\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate,\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(({tile}) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(tile, EventType.CHANGE, (e) => {\n            const state = tile.getState();\n            if (\n              state == TileState.LOADED ||\n              state == TileState.ERROR ||\n              state == TileState.EMPTY\n            ) {\n              unlistenByKey(sourceListenKey);\n              leftToLoad--;\n              if (leftToLoad === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          });\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function ({tile}, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   * @override\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n", "/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  }\n  return new TileRange(minX, maxX, minY, maxY);\n}\n\nexport default TileRange;\n", "/**\n * @module ol/tilecoord\n */\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, tileCoord) {\n  if (tileCoord !== undefined) {\n    tileCoord[0] = z;\n    tileCoord[1] = x;\n    tileCoord[2] = y;\n    return tileCoord;\n  }\n  return [z, x, y];\n}\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n  const [z, x, y] = tileKey\n    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n    .split(',')\n    .map(Number);\n  return getKeyZXY(z, x, y);\n}\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return hashZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * @param {number} z The tile z coordinate.\n * @param {number} x The tile x coordinate.\n * @param {number} y The tile y coordinate.\n * @return {number} Hash.\n */\nexport function hashZXY(z, x, y) {\n  return (x << z) + y;\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  const z = tileCoord[0];\n  const x = tileCoord[1];\n  const y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  const tileRange = tileGrid.getFullTileRange(z);\n  if (!tileRange) {\n    return true;\n  }\n  return tileRange.containsXY(x, y);\n}\n", "/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport DataTile, {asImageLike} from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {createOrUpdate as createTileCoord, getKeyZXY} from '../../tilecoord.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(sourceKey, z, x, y) {\n  return `${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection_ = undefined;\n\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(\n        z,\n        x,\n        y,\n        frameState.pixelRatio,\n        frameState.viewState.projection,\n      );\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection_) {\n      this.renderedProjection_ = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection_) {\n      this.tileCache_.clear();\n      this.renderedProjection_ = frameState.viewState.projection;\n    }\n\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedRevision_) {\n      this.renderedRevision_ = sourceRevision;\n    } else if (this.renderedRevision_ !== sourceRevision) {\n      this.renderedRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(staleKeys[i], z, x, y);\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.get(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.get(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  * maybe skip transition when not fully opaque\n     *  * decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(\n        frameExtent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          renderExtent,\n          z - 1,\n          tilesByZ,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\n        tileState === TileState.EMPTY\n      ) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      this.renderComplete = false;\n\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tilesByZ,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tilesByZ,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (\n              intersects(\n                [x, y, x + w, y + h],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../Map.js\").default} map Map.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n    const postRenderFunction = (map, frameState) => {\n      const tileSourceKey = getUid(tileSource);\n      const wantedTiles = frameState.wantedTiles[tileSourceKey];\n      const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n      this.updateCacheSize(tilesCount);\n      this.tileCache_.expireCache();\n    };\n\n    frameState.postRenderFunctions.push(postRenderFunction);\n\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(\n      this.tileCache_.highWaterMark,\n      tileCount * 2,\n    );\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\n      );\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n", "/**\n * @module ol/layer/Tile\n */\nimport BaseTileLayer from './BaseTile.js';\nimport CanvasTileLayerRenderer from '../renderer/canvas/TileLayer.js';\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} [TileSourceType=import(\"../source/Tile.js\").default]\n * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>\n * @api\n */\nclass TileLayer extends BaseTileLayer {\n  /**\n   * @param {import(\"./BaseTile.js\").Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new CanvasTileLayerRenderer(this, {\n      cacheSize: this.getCacheSize(),\n    });\n  }\n}\n\nexport default TileLayer;\n", "/**\n * @module ol/ImageCanvas\n */\nimport ImageState from './ImageState.js';\nimport ImageWrapper from './Image.js';\n\n/**\n * A function that is called to trigger asynchronous canvas drawing.  It is\n * called with a \"done\" callback that should be called when drawing is done.\n * If any error occurs during drawing, the \"done\" callback should be called with\n * that error.\n *\n * @typedef {function(function(Error=): void): void} Loader\n */\n\nclass ImageCanvas extends ImageWrapper {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {HTMLCanvasElement} canvas Canvas.\n   * @param {Loader} [loader] Optional loader function to\n   *     support asynchronous canvas drawing.\n   */\n  constructor(extent, resolution, pixelRatio, canvas, loader) {\n    const state = loader !== undefined ? ImageState.IDLE : ImageState.LOADED;\n\n    super(extent, resolution, pixelRatio, state);\n\n    /**\n     * Optional canvas loader function.\n     * @type {?Loader}\n     * @private\n     */\n    this.loader_ = loader !== undefined ? loader : null;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = canvas;\n\n    /**\n     * @private\n     * @type {?Error}\n     */\n    this.error_ = null;\n  }\n\n  /**\n   * Get any error associated with asynchronous rendering.\n   * @return {?Error} Any error that occurred during rendering.\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Handle async drawing complete.\n   * @param {Error} [err] Any error during drawing.\n   * @private\n   */\n  handleLoad_(err) {\n    if (err) {\n      this.error_ = err;\n      this.state = ImageState.ERROR;\n    } else {\n      this.state = ImageState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state == ImageState.IDLE) {\n      this.state = ImageState.LOADING;\n      this.changed();\n      this.loader_(this.handleLoad_.bind(this));\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Canvas element.\n   * @override\n   */\n  getImage() {\n    return this.canvas_;\n  }\n}\n\nexport default ImageCanvas;\n", "/**\n * @module ol/resolution\n */\n\n/**\n * @typedef {number|Array<number>} ResolutionLike\n */\n\n/**\n * @param {ResolutionLike} resolution Resolution.\n * @return {number} Resolution.\n */\nexport function fromResolutionLike(resolution) {\n  if (Array.isArray(resolution)) {\n    return Math.min(...resolution);\n  }\n  return resolution;\n}\n"],
  "mappings": "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",
  "names": ["RBush", "equals", "squaredDistance", "transform", "Feature_default", "xhr", "Feature_default", "equals", "Layer_default", "render", "Layer_default", "transform", "Event_default", "EventType_default", "Layer_default", "isEmpty", "render", "transform", "Image_default", "canvasPool", "extend", "width", "height", "xPos", "yPos", "source", "size", "bytesPerPixel", "context", "canvasPool", "imageData", "data", "offset", "len", "canvas", "state", "DataTile_default", "state", "canvasPool", "Tile_default", "createOrUpdate", "createOrUpdate", "Layer_default", "createOrUpdate", "Tile_default", "DataTile_default", "dx", "dy", "i", "equals", "frameState", "Tile_default"]
}
